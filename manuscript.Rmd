---
title             : "visualizemi: Visualization, Effect Size, and Replication of Measurement Invariance for Registered Reports"
shorttitle        : "VISUAL MGCFA"

author: 
  - name          : "Erin M. Buchanan"
    affiliation   : "1"
    corresponding : yes    # Define only one corresponding author
    address       : "326 Market St., Harrisburg, PA, USA"
    email         : "ebuchanan@harrisburgu.edu"

affiliation:
  - id            : "1"
    institution   : "Harrisburg University of Science and Technology"

authornote: |
  Thank you to K.D. Valentine and Chelsea Parlett-Pelleriti for feedback on some ugly graphs.  

abstract: |
  Latent variable modeling as a lens for psychometric theory is a popular tool for social scientists to examine measurement of constructs [@beaujean2014]. Journals such as *Assessment* regularly publish articles supporting measures of latent constructs wherein a measurement model is established. Confirmatory factor analysis can be used to investigate the replicability and generalizability of the measurement model in new samples, while multi-group confirmatory factor analysis is used to examine the measurement model across groups within samples [@brown2015]. With the rise of the replication crisis and "psychology's renaissance" [@nelson2018], interest in divergence in measurement has increased, often focused on small parameter differences within the latent model. This manuscript presents `visualizemi`, an *R* package that provides functionality to calculate multigroup models, partial invariance, visualizations for (non)-invariance, effect sizes for models and parameters, and potential replication rates compared to random models. Readers will learn how to interpret the impact and size of the proposed non-invariance in models with a focus on potential replication and how to plan for registered reports. 
  
keywords          : "multigroup confirmatory factor analysis, measurement invariance, visualization, effect size"

floatsintext      : no
linenumbers       : yes
draft             : no
mask              : no

figurelist        : no
tablelist         : no
footnotelist      : no

classoption       : "man"
bibliography: includes/references.bib

header-includes:
  - |
    \makeatletter
    \renewcommand{\paragraph}{\@startsection{paragraph}{4}{\parindent}%
      {0\baselineskip \@plus 0.2ex \@minus 0.2ex}%
      {-1em}%
      {\normalfont\normalsize\bfseries\typesectitle}}
    
    \renewcommand{\subparagraph}[1]{\@startsection{subparagraph}{5}{1em}%
      {0\baselineskip \@plus 0.2ex \@minus 0.2ex}%
      {-\z@\relax}%
      {\normalfont\normalsize\bfseries\itshape\hspace{\parindent}{#1}\textit{\addperi}}{\relax}}
    \makeatother

csl               : "`r system.file('rmd', 'apa7.csl', package = 'papaja')`"
documentclass     : "apa7"
output            : papaja::apa6_pdf
appendix          :
  - "appendix_1.Rmd"
  - "appendix_2.Rmd"
  - "appendix_3.Rmd"
  - "appendix_4.Rmd"
  - "appendix_5.Rmd"
  - "appendix_6.Rmd"
---

```{r libraries, include = FALSE}
library(papaja)
library(lavaan)
library(broom)
library(dplyr)
library(ggplot2)
library(cowplot)
library(ggridges)
library(tidyr)
library(rio)

# devtools::install_github("psyteachr/introdataviz")
# devtools::install_github("ddueber/dmacs")
# devtools::install_github("doomlab/visualizemi")
library(introdataviz)
library(dmacs)
library(visualizemi)

# make smaller outputs
def.source.hook  <- knitr::knit_hooks$get("source")
knitr::knit_hooks$set(source = function(x, options) {
  x <- def.source.hook(x, options)
  x <- ifelse(!is.null(options$size), 
         paste0("\\", options$size,"\n\n", x, "\n\n \\normalsize"), 
         x)
})
```

```{r analysis-preferences}
# Seed for random number generation
set.seed(84393)
knitr::opts_chunk$set(cache.extra = knitr::rand_seed, cache = TRUE, message = FALSE, warning = FALSE)

boot_rr_DF <- import("manu_data/boot_rr_DF.csv")
boot.partial.invariant <- readRDS("manu_data/boot.partial.invariant.RData")
boot.model.rs <- readRDS("manu_data/boot.model.rs.RData")
boot.partial.rs <- readRDS("manu_data/boot.partial.rs.RData")

boot.df.full <- import("manu_data/boot_DF_full.csv")
boot.effects.summary.full <- import("manu_data/boot_effects_summary_DF_full.csv")
boot.partial.summary.full <- import("manu_data/boot_partial_summary_DF_full.csv")
```

Psychological assessments play a critical role in our ability to measure and analyze constructs to support theories and experimental hypotheses. Defining and creating assessments to validly and reliability measure constructs is often difficult because phenomenon, such as anxiety, are often not directly observable. Instead, we use surveys and questionnaires to indirectly assess the underlying construct [@devellis2022]. Latent variable modeling (i.e., structural equation modeling) is a popular tool for the validation of developed survey instruments to verify scale dimensionality, structure, and model fit. A simple search for scale development reveals thousands of articles in psychology that examine new and previously published work, thus, illustrating the interest in both measurement and the use of validation techniques. Unfortunately, except in specialty journals, much of the validity evidence and/or development for measures used in empirical studies is not reported within the journal article [@barry2014; @weidman2017]. Without this information, it is difficult to interpret individual study conclusions, as validity information allows for judgment of usefulness of the measured values [@flake2020]. Further, the current focus on replication [@makel2012; @makel2014; @zwaan2018], reproducibility [@nelson2018], and the credibility of our results [@vazire2022] has demonstrated questionable measurement practices - decisions that researchers make like survey selection and scoring that impact the results of the study [@flake2020]. Transparent reporting of the use and creation of scales can improve both interpretation and reproducibility when using surveys developed to measure latent constructs [@shadish2001].

A secondary concern for developed measures is the potential for differential responding and assessment within target populations. For example, @trent2013 examined for potential variability in the Revised Child Anxiety and Depression Scale in White and Black youths [@chorpita2000]. They found that the scale mostly functioned the same for both White and Black individuals but differences in averages on individual items could potentially affect the scoring and interpretation of the scale results. This comparison of sub-populations is the test of measurement invariance [@meredith1993]. Invariance or equivalence implies that the scale operates in the same fashion for each sub-group, and thus, differences in the final latent variable scores can interpreted as differences in populations. Non-invariance suggests that individuals respond or interpret items differently, and thus, differences in scores may represent different scores on the latent variable in the population or differences in measurement. Non-invariant measurement may lead to misleading results when making group comparisons, and assessing invariance has become a popular technique in scale development [@vandeschoot2015].

Measurement invariance has been explored and implemented for the last fifty years [@jöreskog1971; @sörbom1978] and implemented in the most popular structural equation modeling programs [@jöreskog2001; @rosseel2012; @boker2011]. @byrne1989 extended the ideas of multi-group testing by suggesting partial invariance [followed by @meredith1993]. Partial invariance occurs when non-invariance is found but can be attributed to only a few parameter estimate differences between groups (i.e., items 1 and 2 have different factor loadings but all others are the same). This testing provided an advantage to understand where the potential non-invariance may occur for further study and interpretation guidelines. As the field pushes back against favoring cutoff criteria and rules of thumb [@marsh2004; @putnick2016], an effect size measure for translating "how much" non-invariance was developed $d_{MACS}$ [@nye2011]. This effect size examines the differences in observed variables between the two groups for both the factor loading and the item intercept; thus, any differences in either or both will increase the effect size for non-invariance [@stark2006].

With $d_{MACS}$ and measurement invariance testing, researchers can begin to quantify how and where their construct measurement may vary between groups. Yet, given the large number of studies that show non-invariance, it is clear that equivalence can be hard to meet. It is difficult to know if non-invariance occurs because of random sampling error, true population differences, or differences in replication and reproducibility of the construct in a new sample. The field of psychology is increasingly interested in pre-registration [i.e., registering plans for a study before data collection, @nosek2018] and the promotion of transparency in study design, implementation, and analysis [@mayo-wilson2021], in addition to supporting replication studies [@zwaan2018]. Registered (replication) reports provide an advantageous avenue for the pre-registration of measurement tests, as they allow a researcher the ability to have their study accepted in principle, regardless of the results of a test of construct validity, reliability, or measurement invariance [@hobson2019; @nosek2014]. However, there are few tools that can provide effect size measures for models, individual parameters, or visualization for researchers to plan for future studies. $d_{MACS}$ provides the opportunity to begin to think about the smallest effect size of interest or the smallest meaningful effect size for measurement invariance and replication [i.e., two studies with overlapping confidence intervals "replicate", even if the test of measurement invariance does not, @lakens2017; @anvari2021]. As mentioned, $d_{MACS}$ has only really been explored for a combined intercept and loadings, and while useful, does not necessarily allow a researcher to pinpoint specific issues within an observed variable.

Therefore, purpose of this manuscript is describe an *R* package, `visualizemi`, that provides functionality to calculate multi-group confirmatory factor analysis, partial invariance tests, visualizations of the size of non-invariance, and potential effect sizes for overall models and individual parameters. No known visualization techniques have been proposed for measurement invariance. By creating panel visualizations, we can supplement a researchers ability to judge the strength of the non-invariance differences and effect size for each item. The proposed effect sizes demonstrate the likelihood of replication with a similar sample as compared to a randomly assigned group model, thus, illustrating what type of measurement one might expect to find, and how different that is from random chance. Within this technique, the individual parameter effect sizes can calculated: both the group differences within a model as compared to random and the likelihood of a parameter replication compared to random groups. Coupled with other indicators (i.e., fit indices differences, $d_{MACS}$), we can move toward a better understanding of how much measurement non-invariance is meaningful. This tutorial and package will help researchers plan future studies and aid in the ability to estimate a smallest effect of interest for measurement invariance studies, rather than relying on fit indices and rules of thumb alone.

By the end of this tutorial manuscript, readers will:

1.  Learn how to use *visualizemi* to analyze multi-group confirmatory factor analysis, examine partial invariance, and create visualizations of parameters.
2.  Learn how to estimate the potential replication of multi-group models and their parameters using bootstrapping compared to a random group model.
3.  Be able to calculate and interpret effect sizes for model and parameter replication, as well as parameter group differences.
4.  Understand the impact of measurement variability on replication and generalizability.

The tutorial will start with simulated data based on known effect sizes using $d_{MACS}$ and demonstrating the package functions for 1) running the multigroup analysis, 2) running a partial invariance analysis, 3) plotting the partial invariance, 4) estimating replication and effect sizes at the model level, and 5) estimating replication and effect sizes at the parameter level. Last, data from @aiena2014 examining the measurement invariance of the RS-14 [@wagnild2009] will be used to demonstrate the application of the package on real data. The *visualizemi* package vignette includes an additional tutorial walk through.

# Method

## Design and Analysis

Data was simulated using the `simulateData` function in the *R* package *lavaan* [@rosseel2012] assuming multivariate normality using a $\mu$ of 0 and $\sigma$ of 1 for the data. This function allows you to write *lavaan* syntax for your model with estimated values to generate data for observed variables (see supplemental for examples). The data included two groups of individuals ("Group 1", "Group 2") for a multi-group confirmatory factor analysis ($n_{group}$ = 250, *N* = 500). The latent variables were assumed to be continuous normal (the package functions do not require this assumption). The model consisted of five observed items predicted by one latent variable (`lv =~ q1 + q2 + q3 + q4 + q5`); however, the demonstration in this manuscript extends to multiple latent variables and other combinations of observed variables. Each item was assumed to be related to the latent variable with loadings approximately equal to .40 to .80, except when cases of non-invariance on the loadings was simulated.

The @brown2015 steps of testing measurement invariance are demonstrated in this manuscript for illustration purposes, but in line with @stark2006 suggestions, the visualizations show the impact of loadings and intercepts together. A convenience function `mgcfa` is used for these steps or other measurement invariance test orders and combinations. Fit indices for the steps for multi-group models are presented in the appendix for comparison of cutoff rules of thumb [@cheung2002] to effect sizes and visualizations presented in this manuscript. Fit indices include Akaike Information Criterion [AIC, @akaike1998], Bayesian Information Criterion [BIC, @schwarz1978], Comparative Fit Index [CFI, @bentler1990], Tucker Lewis Index [TLI, @tucker1973], root mean squared error of approximation RMSEA [@steiger1990], and standardized root mean square residual [SRMR, @bentler1995].

The data was then simulated to represent invariance across all model steps, small, medium, and large invariance using $d_{MACS}$ estimated sizes from @nye2019. While $d_{MACS}$ is used primarily for an effect size of the (non)-invariance for intercepts and loadings together, a similar approach was taken for the estimation of small, medium, and large effects on the residuals. The effect size is presented for all models, calculated from the *dmacs* package [@dueber2023; @nye2011]. Only one item in each model was manipulated from the invariant model to create the non-invariant models. Given the data was simulated with a *z*-score scaling, the loading values were simulated at .30 points apart (given $d_{MACS}$ suggestions of .2, .4, .7), the intercepts at .25 points apart, and the residuals at .25 points apart. To plan a simulation for your own study, these values can be used to simulate small, medium, and large non-invariance effects by first converting data into *z*-score.

# Package Code Examples

The complete code for this manuscript can be found at <https://osf.io/wev5f/>. This tutorial was registered at <https://osf.io/vwf4d>, and the example provided at the end of the manuscript was added after that registration. The *R* package and replication/effect sizes was added after the original manuscript submission.

```{r create-models}
# overall model
model.overall <- "lv =~ q1 + q2 + q3 + q4 + q5
q1 ~ 0*1
lv ~ 1"

# build invariant model one factor
model.invariant.g1 <- "lv =~ .8*q1 + .4*q2 + .6*q3 + .3*q4 + .6*q5 
q4 ~~ 1*q4
q4 ~ 0*1
q1 ~ 0*1
lv ~ 1"
model.invariant.g2 <- "lv =~ .81*q1 + .41*q2 + .61*q3 + .31*q4 + .61*q5
q4 ~~ 1*q4
q4 ~ 0*1
q1 ~ 0*1
lv ~ 1"

# loadings .5, .8, 1.1
model.small.load.g2 <- "lv =~ .81*q1 + .41*q2 + .61*q3 + .5*q4 + .61*q5
q1 ~ 0*1
lv ~ 1"
model.med.load.g2 <- "lv =~ .81*q1 + .41*q2 + .61*q3 + .8*q4 + .61*q5
q1 ~ 0*1
lv ~ 1"
model.large.load.g2 <- "lv =~ .81*q1 + .41*q2 + .61*q3 + 1.1*q4 + .61*q5
q1 ~ 0*1
lv ~ 1"

# build invariance on intercepts .25, .50, and .75
model.small.int.g2 <- "lv =~ .81*q1 + .41*q2 + .61*q3 + .31*q4 + .61*q5
q4 ~ .25*1
q1 ~ 0*1
lv ~ 1"
model.med.int.g2 <- "lv =~ .81*q1 + .41*q2 + .61*q3 + .31*q4 + .61*q5
q4 ~ .5*1
q1 ~ 0*1
lv ~ 1"
model.large.int.g2 <- "lv =~ .81*q1 + .41*q2 + .61*q3 + .31*q4 + .61*q5
q4 ~ .75*1
q1 ~ 0*1
lv ~ 1"

# build invariance on residuals .25, .50, and .75
model.small.res.g2 <- "lv =~ .81*q1 + .41*q2 + .61*q3 + .31*q4 + .61*q5
q4 ~~ .75*q4
q1 ~ 0*1
lv ~ 1"
model.med.res.g2 <- "lv =~ .81*q1 + .41*q2 + .61*q3 + .31*q4 + .61*q5
q4 ~~ .5*q4
q1 ~ 0*1
lv ~ 1"
model.large.res.g2 <- "lv =~ .81*q1 + .41*q2 + .61*q3 + .31*q4 + .61*q5
q4 ~~ .25*q4
q1 ~ 0*1
lv ~ 1"
```

```{r create-data}
# simulate data invariant
df.invariant <- bind_rows(
  simulateData(model.invariant.g1, sample.nobs = 250, 
               meanstructure = T, model.type = "cfa",
               seed = 1234) %>% 
    mutate(group = "Group 1"), 
  simulateData(model.invariant.g2, sample.nobs = 250, 
               meanstructure = T, model.type = "cfa",
               seed = 1234) %>% 
    mutate(group = "Group 2") 
)

# simulate data small load
df.small.load <- bind_rows(
  simulateData(model.invariant.g1, sample.nobs = 250, 
               meanstructure = T, model.type = "cfa",
               seed = 1234) %>% 
    mutate(group = "Group 1"), 
  simulateData(model.small.load.g2, sample.nobs = 250, 
               meanstructure = T, model.type = "cfa",
               seed = 1234) %>% 
    mutate(group = "Group 2") 
)

# simulate data med load
df.med.load <- bind_rows(
  simulateData(model.invariant.g1, sample.nobs = 250, 
               meanstructure = T, model.type = "cfa",
               seed = 1234) %>% 
    mutate(group = "Group 1"), 
  simulateData(model.med.load.g2, sample.nobs = 250, 
               meanstructure = T, model.type = "cfa",
               seed = 1234) %>% 
    mutate(group = "Group 2") 
)

# simulate data large load
df.large.load <- bind_rows(
  simulateData(model.invariant.g1, sample.nobs = 250, 
               meanstructure = T, model.type = "cfa",
               seed = 1234) %>% 
    mutate(group = "Group 1"), 
  simulateData(model.large.load.g2, sample.nobs = 250, 
               meanstructure = T, model.type = "cfa",
               seed = 1234) %>% 
    mutate(group = "Group 2") 
)

# simulate data small int
df.small.int <- bind_rows(
  simulateData(model.invariant.g1, sample.nobs = 250, 
               meanstructure = T, model.type = "cfa",
               seed = 1234) %>% 
    mutate(group = "Group 1"), 
  simulateData(model.small.int.g2, sample.nobs = 250, 
               meanstructure = T, model.type = "cfa",
               seed = 1234) %>% 
    mutate(group = "Group 2") 
)

# simulate data med int
df.med.int <- bind_rows(
  simulateData(model.invariant.g1, sample.nobs = 250, 
               meanstructure = T, model.type = "cfa",
               seed = 1234) %>% 
    mutate(group = "Group 1"), 
  simulateData(model.med.int.g2, sample.nobs = 250, 
               meanstructure = T, model.type = "cfa",
               seed = 1234) %>% 
    mutate(group = "Group 2") 
)

# simulate data large int
df.large.int <- bind_rows(
  simulateData(model.invariant.g1, sample.nobs = 250, 
               meanstructure = T, model.type = "cfa",
               seed = 1234) %>% 
    mutate(group = "Group 1"), 
  simulateData(model.large.int.g2, sample.nobs = 250, 
               meanstructure = T, model.type = "cfa",
               seed = 1234) %>% 
    mutate(group = "Group 2") 
)

# simulate data small res
df.small.res <- bind_rows(
  simulateData(model.invariant.g1, sample.nobs = 250, 
               meanstructure = T, model.type = "cfa",
               seed = 1234) %>% 
    mutate(group = "Group 1"), 
  simulateData(model.small.res.g2, sample.nobs = 250, 
               meanstructure = T, model.type = "cfa",
               seed = 1234) %>% 
    mutate(group = "Group 2") 
)

# simulate data med res
df.med.res <- bind_rows(
  simulateData(model.invariant.g1, sample.nobs = 250, 
               meanstructure = T, model.type = "cfa",
               seed = 1234) %>% 
    mutate(group = "Group 1"), 
  simulateData(model.med.res.g2, sample.nobs = 250, 
               meanstructure = T, model.type = "cfa",
               seed = 1234) %>% 
    mutate(group = "Group 2") 
)

# simulate data large res
df.large.res <- bind_rows(
  simulateData(model.invariant.g1, sample.nobs = 250, 
               meanstructure = T, model.type = "cfa",
               seed = 1234) %>% 
    mutate(group = "Group 1"), 
  simulateData(model.large.res.g2, sample.nobs = 250, 
               meanstructure = T, model.type = "cfa",
               seed = 1234) %>% 
    mutate(group = "Group 2") 
)
```

```{r run-cfa}
# invariant CFA
results.invariant <- 
  mgcfa(model = model.overall, 
        data = df.invariant,
        group = "group",
        group.equal = c("loadings", "intercepts", "residuals"),
        meanstructure = T)

d_invariant <- lavaan_dmacs(
  results.invariant$model_configural, 
  RefGroup = "Group 1")

# loadings
results.small.load <- 
  mgcfa(model = model.overall, 
        data = df.small.load,
        group = "group",
        group.equal = c("loadings", "intercepts", "residuals"),
        meanstructure = T)

results.med.load <- 
  mgcfa(model = model.overall, 
        data = df.med.load,
        group = "group",
        group.equal = c("loadings", "intercepts", "residuals"),
        meanstructure = T)
results.large.load <- 
  mgcfa(model = model.overall, 
        data = df.large.load,
        group = "group",
        group.equal = c("loadings", "intercepts", "residuals"),
        meanstructure = T)

d_small_load <- 
  lavaan_dmacs(results.small.load$model_configural, 
               RefGroup = "Group 1")
d_med_load <- 
  lavaan_dmacs(results.med.load$model_configural, 
               RefGroup = "Group 1")
d_large_load <- 
  lavaan_dmacs(results.large.load$model_configural, 
               RefGroup = "Group 1")

# intercepts
results.small.int <- 
  mgcfa(model = model.overall, 
        data = df.small.int,
        group = "group",
        group.equal = c("loadings", "intercepts", "residuals"),
        meanstructure = T)
results.med.int <- 
  mgcfa(model = model.overall, 
        data = df.med.int,
        group = "group",
        group.equal = c("loadings", "intercepts", "residuals"),
        meanstructure = T)
results.large.int <- 
  mgcfa(model = model.overall, 
        data = df.large.int,
        group = "group",
        group.equal = c("loadings", "intercepts", "residuals"),
        meanstructure = T)

d_small_int <- 
  lavaan_dmacs(results.small.int$model_configural, 
               RefGroup = "Group 1")
d_med_int <- 
  lavaan_dmacs(results.med.int$model_configural, 
               RefGroup = "Group 1")
d_large_int <- 
  lavaan_dmacs(results.large.int$model_configural, 
               RefGroup = "Group 1")

# residuals
results.small.res <-
  mgcfa(model = model.overall, 
        data = df.small.res,
        group = "group",
        group.equal = c("loadings", "intercepts", "residuals"),
        meanstructure = T)
results.med.res <- 
  mgcfa(model = model.overall, 
        data = df.med.res,
        group = "group",
        group.equal = c("loadings", "intercepts", "residuals"),
        meanstructure = T)
results.large.res <- 
  mgcfa(model = model.overall, 
        data = df.large.res,
        group = "group",
        group.equal = c("loadings", "intercepts", "residuals"),
        meanstructure = T)

d_small_res <- 
  lavaan_dmacs(results.small.res$model_configural, 
               RefGroup = "Group 1")
d_med_res <- 
  lavaan_dmacs(results.med.res$model_configural,
               RefGroup = "Group 1")
d_large_res <- 
  lavaan_dmacs(results.large.res$model_configural, 
               RefGroup = "Group 1")
```

## Multi-group CFA Caculation

First, we would create our model code in *lavaan* syntax [@rosseel2012]. The `lv` latent variable predicts the five measured variables, which are present as columns in our `df.invariant` data set. The package does generally require raw data for bootstrapping purposes, and an example of how to simulate data from models and covariance/correlations tables sometimes provided in manuscripts (rather than the raw data) is provided in the supplemental documentation.

*lavaan* automatically sets the mean (i.e., the intercept) for latent variables to zero. If we wish to visualize the impact of the changes in parameter estimates across groups on the latent means, we need to allow the latent mean estimation with `lv ~ 1`. However, adding this estimation into our model will create a non-identified model. To solve this problem, you can set one of the intercepts of another variable to a value to scale the model. Here we will set the scale of the model by using `q1 ~ 0*1`, thus, scaling the expected means to zero. With simulation, this step is easy to know which variable to pick - we set the intercept on the variable we know did not show differences. In real data, you may wish to run the model steps *without* setting this option, examine the results of a configural or separate models, and then add the option for the values most similar. Additionally, you could complete partial invariance steps to determine which value appears most consistent to fix the estimate.

```{r model-example, eval = T, include = T, echo = T, size = "small"}
# create lavaan model
model.overall <- "
# overall one-factor model
lv =~ q1 + q2 + q3 + q4 + q5
# set the intercept (mean) of q1 to zero
q1 ~ 0*1
# allow the lv intercept to be freely estimated
lv ~ 1"
# look at the data
head(df.invariant)
```

The `mgcfa` function is designed to flexibly allow you to leverage `lavaan`'s package functions to calculate multiple measurement steps at once. You would include:

1)  the model syntax in the `model` argument
2)  the dataframe in the `data` argument of our function
3)  the name of the grouping variable in quotes for `group`
4)  and the equality constraints you would like to impose in order in `group.equal`
5)  `...` any other *lavaan* arguments you would like to use such as `meanstructure` or `estimator`.

Note: you can also use `sample.cov`, `sample.mean`, `sample.nobs` in this step for estimation of multi-group models, but simulated dataframes are needed for bootstrapping replication estimates.

```{r mgcfa-example, echo = T, size = "small"}
# run our mgcfa function to run all models
results.invariant <- 
  # name of the saved model syntax
  mgcfa(model = model.overall, 
        # name of the dataframe
        data = df.invariant,
        # name of the grouping variable
        group = "group",
        # equality constraints to impose in order
        group.equal = c("loadings", "intercepts", "residuals"),
        # other options to send to lavaan cfa function
        meanstructure = T)

# what is saved for you
names(results.invariant)
```

The following output is saved:

1)  `model_coef`: The parameter estimates for each model with the model step included in a *model* column. This set of coefficients can be used for other functions. This dataframe is created with *broom*'s `tidy()` function if you wish to recreate this table without running the `mgcfa()` function [@robinson2023].

```{r mgcfa-output1, echo = T, include = T, size = "small"}
results.invariant$model_coef[1:10 , ]
```

2)  `model_fit`: The model fit indices from `fitmeasures()` to review for overall model fit and invariance judgments. The name of the model is included in a *model* column.

```{r mgcfa-output2, echo = T, include = T, size = "small"}
head(results.invariant$model_fit)
```

3)  `model_overall`: A saved *lavaan* fitted model of all groups together without any equality constraints or grouping variables. These objects can be used with any function that normally takes a saved model: `parameterEstimates()`, `modificationIndices()`, `semPlot::semPaths()`, and so on [@epskamp2022].
4)  `group_models`: A list of saved fitted models for each group separately.
5)  `model_configural`: A saved fitted model for the configural model that nests together each group into one model with no other constraints.
6)  `invariance_models`: A list of saved fitted models that consecutively adds `group.equal` constraints.

## Visualization of Invariance

### Package Function

The results from the `model_coef` table can then be used directly in `plot_mi()`. The plot outputs will be described below. First, here are the arguments for the function:

1)  `data_coef`: A tidy dataframe of the parameter estimates from the models. This function assumes you have used `broom::tidy()` on the saved model from *lavaan* and added a column called "model" with the name of the model step [@robinson2023]. This function will only run for models that have used the grouping function (i.e., configural, metric, scalar, and strict or other combinations/steps you wish to examine).
2)  `model_step`: Which model do you want to plot? You should match this name to the one you want to extract from your model column in the `data_coef`.
3)  `item_name`: Which observed variable from your model syntax do you want to plot? Please list this variable name exactly how it appears in the model.
4)  `x_limits`: What do you want the x-axis limits to be for your invariance plot? The default option is to assume the latent variable is standardized, and therefore, -1 to 1 is recommended. Use only two numbers, a lower and upper limit. This value also constrains the latent mean diagram to help zoom in on group differences because the scale of latent means is usually centered over zero. You can use this parameter to zoom out to a more traditional histogram using `c(-2, 2)`.
5)  `y_limits`: What do you want the y-axis limits to be for your invariance plot? Given that the latent variable is used to predict the observed values in the data, you could use the minimum and maximum values found in the data. If that range is large, consider reducing this value to be able to visualize the results (i.e., otherwise it may be too zoomed out to judge group differences). Use only two numbers, a lower and upper limit.
6)  `conf.level`: What confidence limit do you want to plot? Use 1 - $\alpha$.
7)  `model_results`: In this argument, include the saved *lavaan* output for the model listed in the `model_step` argument.
8)  `lv_name`: Include the name of the latent variable, exactly how it is listed in your *lavaan* syntax. You should plot the latent variable that the `item_name` is linked to. If you have items that load onto multiple latent variables, you will need to make multiple plots.
9) `plot_groups`: If you include more than two groups in a multi-group model, the automatic assumption is that you want the first two groups for this visualization. If not, include the names of the groups here to plot. 

```{r plot-example, eval = T, echo = T, include = T, size = "small"}
invariant.plot <- 
  plot_mi(
    # output from model_coef
    data_coef = results.invariant$model_coef, 
    # which model do you want to plot
    model_step = "Configural", 
    # name of observed item
    item_name = "q4", 
    # latent variable limits to graph
    x_limits = c(-1,1), 
    # Y min and max in data 
    y_limits = c(min(df.invariant$q4), max(df.invariant$q4)),
    # what ci do you want
    conf.level = .95, 
    # what model results do you want 
    model_results = results.invariant$model_configural,
    # which latent variable do you want 
    lv_name = "lv" 
)

names(invariant.plot)
```

The output from this function are several *ggplot2* objects that can be edited or saved directly using *ggplot2* functionality [@R-ggplot2]. 

1) `complete`: The output from this model can be found in Figure \@ref(fig:invariant-pic). On the left hand side, the item invariance is plotted, and on the right hand side, the latent mean distributions for the two groups are plotted. In the item invariance sub-plot, the visualization includes all three components traditionally seen in MGCFA testing steps: loadings, intercepts, and residuals. Each visualization element was designed to match the traditional visualization for that type of output. All parameter estimates are plotted on the unstandardized estimates and their confidence interval based on the standard error of the estimate. All plots are made with *ggplot2* and *cowplot* [@wilke2020].

```{r invariant-pic, include = T, fig.cap = "Invariant Model Visualization"}
invariant.plot$complete
```

2) `intercept`: Only the left hand side of the complete plot designed to represent intercepts and factor loadings. Factor loadings represent the slope of the regression equation for the latent variable predicting the scores on the observed variable ($\hat{Y} \sim b_0 + b_1X + \epsilon$). The y-axis indicates the observed variable scores, and here, the plot includes the entire range of the scale of the data for item four. The coefficient ($b_1$) for group 1 was `r apa_num(results.invariant$model_coef %>% filter(model == "Configural") %>% filter(grepl("q4", term)) %>% filter(op == "=~") %>% slice_head() %>% pull(estimate))`, while the coefficient for group 2 was `r apa_num(results.invariant$model_coef %>% filter(model == "Configural") %>% filter(grepl("q4", term)) %>% filter(op == "=~") %>% slice_tail() %>% pull(estimate))`. The ribbon bands around the plotted slopes indicate the confidence interval for that estimate. In this plot, while the coefficients for each group are not literally equal, the overlapping and parallel slope bands indicate they are not different practically.

The item intercepts ($b_0$) are plotted on the middle line where they would cross the y-axis at a latent variable score of zero. These are represented by a dot with a set of confidence error bars around the point. The intercept for group 1 was `r apa_num(results.invariant$model_coef %>% filter(model == "Configural") %>% filter(grepl("q4", term)) %>% filter(op == "~1") %>% slice_head() %>% pull(estimate))`, while the coefficient for group 2 was `r apa_num(results.invariant$model_coef %>% filter(model == "Configural") %>% filter(grepl("q4", term)) %>% filter(op == "~1") %>% slice_tail() %>% pull(estimate))`. In this invariant depiction, the overlap in the intercepts is clear, indicating they are not different. You can use `y_limits` to zoom in on the graph if these are too small to be distinguishable.

3) `mean`: The right hand side of the complete plot graphing the latent variable means and density from the data. The latent variable is shown on the x-axis using standardized values (i.e., *z*-scores) where -1 indicates one standard deviation below the mean for the latent variable, 0 indicates the mean for the latent variable and so on. The lines indicate the means of the latent variables from the simulated dataset. Group labels are represented in the figure caption on the bottom. Group 1 is usually the group that is alphabetically first in the data set or whichever group is the first that appears when using the `levels()` command.

4) `variance`: A split geom violin plot indicating the variance distribution of the plotted item. Residuals are trickier to plot, as they are the left over error when predicting the observed variables $\epsilon$. It is tempting to plot this value as the confidence band around the slope, however, that defeats the purpose of understanding that the slopes are estimated separately from the residuals, and both have an associated variability around their parameter estimate. Therefore, residuals are represented in the inset picture at the bottom right of the item invariance plot. The black bars represent the estimated residual for each group (group 1: `r apa_num(results.invariant$model_coef %>% filter(model == "Configural") %>% filter(grepl("q4", term)) %>% filter(op == "~~") %>% slice_head() %>% pull(estimate))`, group 2: `r apa_num(results.invariant$model_coef %>% filter(model == "Configural") %>% filter(grepl("q4", term)) %>% filter(op == "~~") %>% slice_tail() %>% pull(estimate))`). The distributions are plotted to represent the normal spread of values using the standard error of the residuals. The violin plot allows for direct comparison of those residuals and their potential distributions. Note that the placement has nothing to do with the x or y-axis and is designed to always show in the same location, regardless of size/value. The plots are included separately so they can be arranged in a different fashion if desired. 

### Simulated Results

The $d_{MACS}$ value for item 4 in the invariant model was `r apa_num(d_invariant)$DMACS[4]`, representing a nil or unimportant difference in this manuscript. It is important to note that while @nye2019 suggests specific sizes for small, medium, and large, each researcher should determine for themselves what effects represent. Figure \@ref(fig:small-load-pic) displays the results from the small ($d_{MACS}$ = `r apa_num(d_small_load)$DMACS[4]`) difference in loadings, while Figure \@ref(fig:med-load-pic) displays the results from the medium ($d_{MACS}$ = `r apa_num(d_med_load)$DMACS[4]`) difference in loadings, and Figure \@ref(fig:large-load-pic) shows the large ($d_{MACS}$ = `r apa_num(d_large_load)$DMACS[4]`) differences. When investigating the slope values, we can clearly see the change in the loading for the second group (the only manipulated variable, although random data set generation may also change intercepts and residuals slightly). At the medium effect size, we see that the confidence bands do not overlap (at the edges), and at the large effect size, we can see a clear separation of two lines. Note that the intercepts in this model are estimated as equal so the loading representation will not literally separate, but the steepness of the lines is the indicator of the difference between the slopes. You can imagine these lines are interpreted like a simple slopes analysis for interactions in regression [@cohen2003]. When simple slopes for interactions are plotted, if they are parallel, there is no interaction, and if they cross, then there is an interaction. Here, we can use this same logic. If they are parallel, there is likely invariance (they are the same), and the further from parallel they become, the larger the effect size for the differences between group loadings.

The latent means in Figure \@ref(fig:large-load-pic) do appear to show differences, albeit visually small. The latent means diagram shows the impact of any group differences that aren't constrained, and this image shows the configural model (as the metric model would force them to be equal). In the simulated model, the *only* manipulated parameter is question 4's loading. In real models, the differences may be larger due to other variation found in the parameter estimates. Therefore, once you discover items you believe would make a model "partially" invariant, you may wish to estimate that model and graph the item again using the partially invariant model to see only the effect of the non-invariant items. Additionally, consider that we set the scaling of the model to 0. The estimate for the lv mean in the large loading model was group 1: `r apa_num(results.invariant$model_coef %>% filter(model == "Configural") %>% filter(grepl("lv", term)) %>% filter(op == "~1") %>% slice_head() %>% pull(estimate))`, and group 2: `r apa_num(results.invariant$model_coef %>% filter(model == "Configural") %>% filter(grepl("lv", term)) %>% filter(op == "~1") %>% slice_tail() %>% pull(estimate))`, which results in `r apa_num(results.invariant$model_coef %>% filter(model == "Configural") %>% filter(grepl("lv", term)) %>% filter(op == "~1") %>% slice_head() %>% pull(estimate) - results.invariant$model_coef %>% filter(model == "Configural") %>% filter(grepl("lv", term)) %>% filter(op == "~1") %>% slice_tail() %>% pull(estimate))` difference in group means. The practical implications of this difference will depend on the research and interpretations of the researcher.

```{r small-load-pic, include = T, fig.cap = "Small Loadings Model Visualization"}
plot_mi(
  data_coef = results.small.load$model_coef, # output from model_coef
  model_step = "Configural", # which model
  item_name = "q4", # name of observed item
  x_limits = c(-1,1), # LV limits to graph
  y_limits = c(min(df.small.load$q4), max(df.small.load$q4)), # Y min and max in data 
  conf.level = .95, # what ci do you want
  model_results = results.small.load$model_configural, # what model results do you want 
  lv_name = "lv"
)$complete
```

```{r med-load-pic, include = T, fig.cap = "Medium Loadings Model Visualization"}
plot_mi(
  data_coef = results.med.load$model_coef, # output from model_coef
  model_step = "Configural", # which model
  item_name = "q4", # name of observed item
  x_limits = c(-1,1), # LV limits to graph
  y_limits = c(min(df.med.load$q4), max(df.med.load$q4)), # Y min and max in data 
  conf.level = .95, # what ci do you want
  model_results = results.med.load$model_configural, # what model results do you want 
  lv_name = "lv"
)$complete
```

```{r large-load-pic, include = T, fig.cap = "Large Loadings Model Visualization"}
plot_mi(
  data_coef = results.large.load$model_coef, # output from model_coef
  model_step = "Configural", # which model
  item_name = "q4", # name of observed item
  x_limits = c(-1,1), # LV limits to graph
  y_limits = c(min(df.large.load$q4), max(df.large.load$q4)), # Y min and max in data 
  conf.level = .95, # what ci do you want
  model_results = results.large.load$model_configural, # what model results do you want 
  lv_name = "lv"
)$complete
```

For intercepts, the small (Figure \@ref(fig:small-int-pic)), medium (Figure \@ref(fig:med-int-pic)), and large (Figure \@ref(fig:large-int-pic)) depictions represent $d_{MACS}$ values of `r apa_num(d_small_int)$DMACS[4]`, `r apa_num(d_med_int)$DMACS[4]`, and `r apa_num(d_large_int)$DMACS[4]`, respectively. Intercept differences can be clearly seen represented by the spacing out of the intercept locations (and thus, the overall line as well). While the changes in intercept do not appear to change the latent means, the caveat to this simulation is that only item four was manipulated. An example is provided below that demonstrates large changes in latent means.

```{r small-int-pic, include = T, fig.cap = "Small Intercepts Model Visualization"}
plot_mi(
  data_coef = results.small.int$model_coef, # output from model_coef
  model_step = "loadings", # which model
  item_name = "q4", # name of observed item
  x_limits = c(-1,1), # LV limits to graph
  y_limits = c(min(df.small.int$q4), max(df.small.int$q4)), # Y min and max in data 
  conf.level = .95, # what ci do you want
  model_results = results.small.int$invariance_models$model.loadings, # what model results do you want 
  lv_name = "lv"
)$complete
```

```{r med-int-pic, include = T, fig.cap = "Medium Intercepts Model Visualization"}
plot_mi(
  data_coef = results.med.int$model_coef, # output from model_coef
  model_step = "loadings", # which model
  item_name = "q4", # name of observed item
  x_limits = c(-1,1), # LV limits to graph
  y_limits = c(min(df.med.int$q4), max(df.med.int$q4)), # Y min and max in data 
  conf.level = .95, # what ci do you want
  model_results = results.med.int$invariance_models$model.loadings, # what model results do you want 
  lv_name = "lv"
)$complete
```

```{r large-int-pic, include = T, fig.cap = "Large Intercepts Model Visualization"}
plot_mi(
  data_coef = results.large.int$model_coef, # output from model_coef
  model_step = "loadings", # which model
  item_name = "q4", # name of observed item
  x_limits = c(-1,1), # LV limits to graph
  y_limits = c(min(df.large.int$q4), max(df.large.int$q4)), # Y min and max in data 
  conf.level = .95, # what ci do you want
  model_results = results.large.int$invariance_models$model.loadings, # what model results do you want 
  lv_name = "lv"
)$complete
```

Last, the effect of the residuals is plotted in small (Figure \@ref(fig:small-res-pic)), medium (Figure \@ref(fig:med-res-pic)), and large (Figure \@ref(fig:large-res-pic)) formats. While $d_{MACS}$ values are not technically available for the residuals, our models showed `r apa_num(d_small_res)$DMACS[4]`, `r apa_num(d_med_res)$DMACS[4]`, and `r apa_num(d_large_res)$DMACS[4]`, respectively. These differences in values are variable due to the random generation of data sets for each measurement invariance manipulation. At first glance, the differences in the small chart may seem large, because the black lines are not touching, but notice that the distributions overlap, indicating a likely small difference. The medium and large differences better illustrate differences in residuals across groups. Further, the impact of the residuals on the shape of the latent mean distribution can also been seen (and unintentionally, in the first figures as well due to random variation). The impact is due to the standard error of the residuals, as smaller standard errors represent lepokurtic distributions (taller), and larger standard errors represent platykurtic distributions (flatter). The effect size difference of the residuals does not appear to change the effects in the latent means.

```{r small-res-pic, include = T, fig.cap = "Small Residuals Model Visualization"}
plot_mi(
  data_coef = results.small.res$model_coef, # output from model_coef
  model_step = "intercepts", # which model
  item_name = "q4", # name of observed item
  x_limits = c(-1,1), # LV limits to graph
  y_limits = c(min(df.small.res$q4), max(df.small.res$q4)), # Y min and max in data 
  conf.level = .95, # what ci do you want
  model_results = results.small.res$invariance_models$model.intercepts, # what model results do you want 
  lv_name = "lv"
)$complete
```

```{r med-res-pic, include = T, fig.cap = "Medium Residuals Model Visualization"}
plot_mi(
  data_coef = results.med.res$model_coef, # output from model_coef
  model_step = "intercepts", # which model
  item_name = "q4", # name of observed item
  x_limits = c(-1,1), # LV limits to graph
  y_limits = c(min(df.med.res$q4), max(df.med.res$q4)), # Y min and max in data 
  conf.level = .95, # what ci do you want
  model_results = results.med.res$invariance_models$model.intercepts, # what model results do you want 
  lv_name = "lv"
)$complete
```

```{r large-res-pic, include = T, fig.cap = "Large Residuals Model Visualization"}
plot_mi(
  data_coef = results.large.res$model_coef, # output from model_coef
  model_step = "intercepts", # which model
  item_name = "q4", # name of observed item
  x_limits = c(-1,1), # LV limits to graph
  y_limits = c(min(df.large.res$q4), max(df.large.res$q4)), # Y min and max in data 
  conf.level = .95, # what ci do you want
  model_results = results.large.res$invariance_models$model.intercepts, # what model results do you want 
  lv_name = "lv"
)$complete
```

## Partial Invariance Calculation

### Package Function

The results of the simulated models are presented in the appendix, demonstrating that each simulated dataset shows partial invariance if item four is allowed to vary between groups. The function takes the following arguments:

1) `saved_model`: The saved *lavaan* model with the equality constraints at the level of measurement invariance you would like to examine for partial invariance. 
2) `data`: The dataframe where the model was estimated. 
3) `model`: The model syntax for the overall model.
4) `group`: The grouping variable column in the dataframe. 
5) `group.equal`: The equality constraints including in your original multi-group tests. 
6) `partial_step`: The level of partial invariance you wish to test. 

```{r partial-example, echo = T, size = "small"}
partial.invariant <-
  partial_mi(
    # saved model output with constraints
    saved_model = results.invariant$invariance_models$model.residuals,
    # dataframe from model 
    data = df.invariant,
    # model syntax 
    model = model.overall,
    # group column name 
    group = "group",
    # group equality constraints from your mgcfa
    group.equal = c("loadings", "intercepts", "residuals"),
    # which step you want to examine for partial invariance
    partial_step = "residuals"
    )

names(partial.invariant)
```

In this function, each parameter with the appropriate *lavaan* syntax is relaxed individually (i.e., `~1` for intercepts, `~~` for residuals, etc.). The fitted models are saved in the `models` output, and the `fit_table` output includes all fit indices for each model to investigate potential areas of partial invariance based on the researcher's desired criterion. Note: the `partial_step` function is used to determine which types of `op` or operators to freely estimate between groups. If one chooses residuals, you will also freely estimate the residual for the latent variable or any other residuals found in the model. These items may be ignored if they were not meant to be included. 

```{r partial-example2, echo = T, size = "small"}
head(partial.invariant$fit_table %>% 
       dplyr::select(free.parameter, cfi, rmsea))
```

## Replication and Effect Size: Model

### Package Function

The `bootstrap_rr` function in *visualizemi* was designed to estimate the likely replication of overall model invariance with the assumption that the data used for the estimation represents the larger population. The following arguments are used:

1) `saved_configural`: a saved fitted model at the configural level with no equality constraints. This model should include all other *lavaan* settings you would like to use, such as `estimator` or `ordered`.

```{r boot-rr, echo = T, eval = F, size = "small"}
boot.model.invariant <- 
  bootstrap_rr(
    # saved configural model 
    saved_configural = results.invariant$model_configural,
    # dataframe
    data = df.invariant,
    # model syntax
    model = model.overall, 
    # group variable column in dataframe
    group = "group",
    # number of bootstraps
    nboot = 1000, 
    # which fit index you would like to use
    invariance_index = "cfi",
    # what is your criterion for that fit index
    invariance_rule = .01,
    # what equality constraints are you testing 
    group.equal = c("loadings", "intercepts", "residuals")
  )
```

The data included in this function will be sampled, with replacement, at the same size as the current dataset, and the included invariance equality constraints are estimated. Each step will be compared to the previous step using the invariance index and comparison rule entered. The output is a dataframe of the proportion of non-invariant bootstraps from the real data and the same bootstrapped dataset with the group labels randomly assigned. The effect size comparison of proportions, $h$, for non-invariant comparisons:

$$h_{nmi} = 2 \times (asin\sqrt{p_{data}} - asin\sqrt{p_{random}})$$
The alternative, $h_{mi}$, for effect size of measurement invariance replication would simply be the inverse sign of $h_{nmi}$ and is also included in the table. Two additional columns $h_{nmi_p}$ and $h_{nmi_p}$ represent the $h$ values divided by the upper bound of $h$ (i.e., $\pi$), to help with interpretation of the effect size (thus, bounding $h$ to -1 to 1).

### Simulated Results

Figure \@ref(fig:boot-rr-pic) portrays the $h_{nmi_p}$ values by simulated non-invariance, strength of non-invariance, and type of equality constraint. This image represents 100 simulations of data by 1000 bootstrapped runs (averaged) to explore the expected pattern of results. The bars are arranged to show what a researcher might inspect when thinking about replication possibilities and their effect sizes (i.e., only three bars for each equality constraint would be calculated). 

```{r boot-rr-pic, include = T, fig.cap = "Visualization of the effect size of bootstrapped replication proportions on simulated data. Each panel indicates the simulated data type, colors represent the differences in the strength of the non-invariance, and the bars on the x-axis represent the effect size for the equality constraint. "}

boot_rr_DF <- boot_rr_DF %>% 
  mutate(type_size = ifelse(
    type == "Invariant", "None", ifelse(
      grepl("Small", type), "Small", ifelse(
        grepl("Medium", type), "Medium", "Large"
      )
    )
  ),
  type_type = ifelse(
    type == "Invariant", "Invariant", ifelse(
      grepl("Loadings", type), "Loadings", ifelse(
        grepl("Intercepts", type), "Intercepts", "Residuals"
      )
    ) 
  ),
  model = factor(model, 
                 levels = c("loadings", "intercepts", "residuals"),
                 labels = c("Loadings", "Intercepts", "Residuals")),
  type_size = factor(type_size, 
                     levels = c("None", "Small", "Medium", "Large")),
  type_type = factor(type_type, 
                     levels = c("Invariant", "Loadings", "Intercepts", "Residuals")))

prop_boot_rr <- ggplot(boot_rr_DF %>% 
                         filter(type_type != "Invariant"), 
                       aes(x = model, 
                       y = h_nmi_p,
                       fill = type_size)) + 
  stat_summary(fun = "mean", 
               position = "dodge", 
               geom = "bar") + 
  stat_summary(fun.data = "mean_cl_normal",
               geom = "errorbar", 
               position = position_dodge(width = .9),
               width = .2) + 
  theme_classic() + 
  facet_grid(type_type~type_size) + 
  scale_fill_discrete(name = "Size of Non-Invariance") + 
  xlab("Equality Constraints") + 
  ylab("Normalized Effect Size") + 
  theme(legend.position = "bottom") + 
  geom_hline(yintercept = 0) +
  # geom_hline(yintercept = 1) + 
  NULL

prop_boot_rr

means_invariant <- boot_rr_DF %>% filter(type == "Invariant") %>% group_by(model) %>% summarize(mean_h = mean(h_nmi_p))
```

In the data that was simulated to be invariant between groups, effect sizes are still non-zero (loadings $h_{nmi_p}$ = `r apa_num(means_invariant$mean_h[1])`, intercepts = $h_{nmi_p}$ = `r apa_num(means_invariant$mean_h[2])`, $h_{nmi_p}$ = `r apa_num(means_invariant$mean_h[3])`). This result mirrors the effects found in the literature - that often, many models fail to show invariance, and potentially not because measurement is poor but because of natural random variation in parameter estimates. This result also indicates the need to be able to identify if specific parameters are driving the differences, which is shown in the next section. 

Next, Figure \@ref(fig:boot-rr-pic) demonstrates the patterns one might find for small, medium, and large effects at each type of invariance when data is simulated with *one* difference. For loadings, the pattern shows a larger effect for loadings with zero or negative effect sizes for other effect sizes. The intercept simulations show non-zero effect sizes in the loadings and intercepts, likely for the same reasons $d_{MACS}$ is interpreted as a combined effect size. When intercepts are changed, loadings may naturally shift with those means. Last, the residual results present an unexpected pattern, wherein the effect is primarily seen in the loadings, rather than the residuals step. However, when distributions of error variance are different, one may expect that those effects are pushed toward the loadings as well (as values can vary more, thus potentially weakening the relationship between observed and latent variable). 

An example of interpretation on real data is given in a later section. From a research study, only one effect size for each equality constraint would be calculated. The interpretation will often be up to the researcher's smallest effect of interest, and this simulation gives some guidance that the values should not be interpreted with traditional rules of thumb. The pattern of effects is potentially the most useful information: 1) positive effects on the loadings with negative or very close to zero effects on the other parameters may indicate a non-replication in loadings, 2) equal effects on loadings and intercepts with smaller or negative effects may indicate intercepts may be an issue, and 3) residuals may be determined by the same pattern as loadings but with a smaller ratio of loadings to residuals effect (i.e., loadings $h_{nmi}$ / residuals $h_{nmi}$. The "size" could be determined by the ratio of effect sizes for each constraint. Of course, this represents one simulation study, and results from many studies in a meta-analysis would be fruitful for future work. 

## Replication and Effect Size: Parameters

### Package Function

After examining the overall model potential replication effect size, the individual parameters within a model can be bootstrapped for partial invariance to with that parameter relaxed (overall partial model statistics) and the difference in group parameter estimates (parameter effect size). This function uses arguments seen in other functions, so they will not be repeated here. The general setup consists of using the model you think could be partially invariant in the `saved_model` argument and the fit index for comparison for the model with less constraints in `invariance_compare`. This example examines the loadings in the invariant model, so `saved_model` uses the `mgcfa` output for equality constraints present on the loadings and compares that model to the configural model with no equality constraints on the loadings. The `partial_step` argument will be used to determine which operation syntax (i.e. `=~` for loadings) to relax for modeling. 

```{r boot-partial, echo = T, size = "small", eval = F}
boot.partial.invariant <- 
      bootstrap_partial(
        # saved model you want to examine the partial loadings for 
        saved_model = results.invariant$invariance_models$model.loadings,
        # the dataset 
        data = df.invariant, 
        # the model 
        model = model.overall,
        # the group variable in the dataset
        group = "group", 
        # number of bootstraps
        nboot = 1000,
        # which fit index you would like to use to determine partial invariance
        invariance_index = "cfi", 
        # what is the invariance rule 
        invariance_rule = .01, 
        # what are we comparing the saved model fit index to 
        invariance_compare = fitmeasures(results.invariant$model_configural, "cfi"), 
        # what step are we using for invariance
        partial_step = "loadings", 
        # what equality constraints should be imposed 
        group.equal = c("loadings")
      )
```

```{r partial-boot-print, echo = T, size = "small"}
names(boot.partial.invariant)
```

The saved output includes several dataframes and plots. The first is the `boot_DF` which the summary of each run in a dataframe for plotting or summarization. This dataframe includes the estimate for each paramter (`term`) separated by group and type (`boot_1`, `boot_2` are the bootstrapped estimates for group 1 and group 2, while the same `random` columns indicate the randomly assigned groups). The fit index used to determine invariance is included for bootstrapped and random estimates, and then the differences between groups and if they were "invariant" or not given the researcher supplied rule. 

```{r boot-partial-DF, echo = T, size = "small"}
head(boot.partial.invariant$boot_DF)
```

Next, the `boot_summary` includes a summarized form of the bootstrapped results from separated by bootstrapping versus random and invariant/non-invariant. The $d_s$ for between groups Cohen's $d$ is shown below, and the non-central confidence interval is included. Effect sizes are only calculated when the number of bootstrapped estimates is at least 10% of the data - therefore, you would not receive effect sizes with almost no bootstrapped runs. This dataframe should be used to determine which parameter may be different and at what size between groups in a replication of the study. 

```{r boot-summary-DF, echo = T, size = "small"}
boot.partial.invariant$boot_summary %>% 
  dplyr::select(term, d_boot, d_random)
```

The `boot_effects` table creates a summary similar to the overall model replication table based on the proportion of runs that were considered invariant versus not for each parameter. Note that the effects match the overall results, such that simulated invariant data appears to still show the likelihood that loadings may not replicate in a similar dataset.  

```{r boot-effects-DF, echo = T, size = "small"}
boot.partial.invariant$boot_effects
```

Plots of the results from dataframes can be found within the `bootstrap_partial()` function. Figure \@ref(fig:invariance-partial-fig) shows the difference between parameters for groups in the bootstrapped and randomly assigned group runs. Figure \@ref(fig:density-partial-fig) shows the density plot of the estimates for each group organized by bootstrapped and randomly assigned groups and the invariance decision for each bootstrapped run. Last, Figure \@ref(fig:effect-partial-fig) indicates the $d_s$ value between groups with an indication of the number of data points in each estimate (i.e., dot size). These visualizations should allow a researcher to understand the likelihood of replication for each parameter, as well as the potential size of the differences. Therefore, one could indicate a specific smallest effect size of interest, rather than a invariance cut-off rule of thumb when planning a replication or registered report. 

```{r invariance-partial-fig, include = T, fig.cap = "Visualization of the difference score between groups by parameter for invariant and non-invariant bootstrapped and randomly assigned group data."}
boot.partial.invariant$invariance_plot
```

```{r density-partial-fig, include = T, fig.cap = "Visualization of the number of estimates for each group by bootstrapped and randomly assigned group runs by their invariance decision."}
suppressMessages(boot.partial.invariant$density_plot)
```

```{r effect-partial-fig, include = T, fig.cap = "Visualization of effect size between groups by parameter for invariant and non-invariant bootstrapped and randomly assigned group data. The size of the dots indicate the number of data points for that estimate."}
boot.partial.invariant$effect_invariance_plot
```

### Simulated Results

```{r create-plot-partial}
# make all the graphs boot long ----
boot_long <- 
  bind_rows(boot.df.full %>% 
              dplyr::select(term, boot_difference, boot_index_difference, type) %>% 
              rename(difference = boot_difference, index_difference = boot_index_difference) %>%
              mutate(type_estimate = "Bootstrapped"), 
            boot.df.full %>% 
              dplyr::select(term, random_difference, random_index_difference, type) %>% 
              rename(difference = random_difference, index_difference = random_index_difference) %>% 
              mutate(type_estimate = "Random")) %>% 
  mutate(type_together = paste0(type, " " , type_estimate ))

label_graph <- c(`TRUE` = "Invariant", `FALSE` = "Non-Invariant")

# make all the graps summary long ----
# summarize the overall
boot.partial.summary <- boot.partial.summary.full %>% 
  dplyr::select(-run_number, computer) %>% 
  group_by(term, invariant, type) %>% 
  summarize_at(vars(mean_boot_1:d_random_high), mean, na.rm = TRUE)
 
boot_summary_long <- 
  bind_rows(boot.partial.summary %>% 
              dplyr::select(term, invariant, n_boot, type, starts_with("d_boot")) %>% 
              rename(n = n_boot, 
                     d_low = d_boot_low, 
                     d = d_boot, 
                     d_high = d_boot_high) %>% 
              mutate(type_estimate = "Bootstrapped"), 
            boot.partial.summary %>% 
              dplyr::select(term, invariant, n_random, type,
                                    starts_with("d_random")) %>% 
              rename(n = n_random, 
                     d_low = d_random_low, 
                     d = d_random, 
                     d_high = d_random_high) %>% 
              mutate(type_estimate = "Random"))

## make all the graphs effects long ----
# summarize the effects
boot.effects.summary <- boot.effects.summary.full %>% 
  dplyr::select(-run_number, -computer) %>% 
  group_by(term, type) %>% 
  summarize_at(vars(non_invariant:h_mi_p), mean, na.rm = TRUE)

density_long <- 
  bind_rows(
    boot.df.full %>% 
      dplyr::select(term, boot_index_difference, boot_1, boot_2, type) %>% 
      pivot_longer(cols = c(boot_1, boot_2), 
                   names_to = "group", 
                   values_to = "estimate") %>% 
      rename(invariant = boot_index_difference) %>% 
      mutate(type_estimate = "Bootstrapped"), 
    boot.df.full %>% 
      dplyr::select(term, random_index_difference, random_1, random_2, type) %>% 
      pivot_longer(cols = c(random_1, random_2), 
                   names_to = "group", values_to = "estimate") %>% 
      rename(invariant = random_index_difference) %>% 
      mutate(type_estimate = "Random")) %>% 
  mutate(group = gsub("boot_1|random_1", "Group 1", group), 
         group = gsub("boot_2|random_2", "Group 2", group), 
         invariant = factor(invariant, 
                            levels = c("TRUE", "FALSE"), 
                            labels = c("Invariant", "Non-Invariant")))

```

Figure \@ref(fig:effect-large-loading-pic) shows the effect size differences within large loadings simulations. The results demonstrate that most of the loadings were considered non-invariant in the bootstrapped models (while holdings all others equal). This result is partially due to simulating very good data, so small changes in loadings results in a drop in fit for our chosen invariance index. However, we can use this graph to show that question four shows a possible effect size ranging from `r boot_summary_long %>% filter(type == "Large Loadings") %>% filter(invariant == FALSE) %>% filter(term == "lv =~ q4") %>% filter(type_estimate == "Bootstrapped") %>% pull(d_low) %>% apa_num()` to `r boot_summary_long %>% filter(type == "Large Loadings") %>% filter(invariant == FALSE) %>% filter(term == "lv =~ q4") %>% filter(type_estimate == "Bootstrapped") %>% pull(d_high) %>% apa_num()`. The $h_{nmi_p}$ value for question four was `r boot.effects.summary %>% filter(type == "Large Loadings") %>% filter(term == "lv =~ q4") %>% pull(h_nmi_p) %>% apa_num()`, representing about a quarter of a possible total effect. Last, the density plot in Figure \@ref(fig:density-large-loading-pic) shows the separation of the two different groups loadings in item four, thus, illustrating group differences in the findings for their loadings. Each of the other combination of plots can be found in the supplemental materials. 

```{r effect-large-loading-pic, fig.cap="Bootstrapped and Random Group effect size differences in loadings for the Large Loading difference simulation. The size of the point reprensents the number of data points included in that calculation."}
effect_invariance_plot <- 
  ggplot(boot_summary_long %>% 
           filter(type == "Large Loadings"), 
         aes(term, d, color = type_estimate)) + 
  theme_classic() + 
  facet_wrap(~invariant, labeller = as_labeller(label_graph)) +
  scale_color_discrete(name = "Type of Estimate") + 
  geom_point(aes(size = n)) + 
  geom_errorbar(aes(ymin = d_low, ymax = d_high), width = 0.2) + 
  xlab("Estimated Item") + 
  ylab("Group Effect Size") + 
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1), 
        legend.position = "bottom") + 
  geom_hline(yintercept = 0) + 
  coord_flip() 

suppressWarnings(effect_invariance_plot)
```

```{r density-large-loading-pic, fig.cap="Bootstrapped and Random density plots for invariant and non-invariant bootstrapped partial effects examining only large loadings."}
density_plot <- ggplot(density_long %>% 
                        filter(type == "Large Loadings"), 
                       aes(x = estimate, y = term, fill = group)) + 
  geom_density_ridges(alpha = 0.7, scale = 0.9) + 
  facet_grid(invariant ~ type_estimate) + 
  theme_classic() + 
  xlab("Estimated Score") + 
  ylab("Parameter") + 
  scale_fill_discrete(name = "Group")

suppressMessages(density_plot)
```

## An Example Analysis

```{r grab-data, eval = F, include = F}
library(rio)

DF <- bind_rows(
  import("data/Adult CFA.sav") %>% dplyr::select(-Age) %>% 
    mutate(sample = "Clinical"),
  import("data/Adult EFA.sav") %>% dplyr::select(-Age) %>% 
    mutate(sample = "Clinical"),
  import("data/Student CFA.sav") %>% dplyr::select(-Age) %>% 
    mutate(sample = "Student"),
  import("data/Student EFA.sav") %>% dplyr::select(-Age) %>% 
    mutate(sample = "Student")
) %>% dplyr::select(RS1:RS14, sample)

save(DF, file = "RS14.Rdata")
```

@aiena2014 examined the RS-14 [@wagnild2009] exploring the factor structure of the Resiliency Scale in a clinical sample receiving treatment services and a college student sample. Measurement invariance was calculated for differences separately for these samples for gender and race finding a partially invariant models with a few item intercepts or residuals that differed between groups. @aiena2014 did not compare the clinical to the student sample for measurement invariance, and it is reasonable to expect potential differences in these two populations. This example will demonstrate the procedure for researchers who wish to use partial invariance steps and how to interpret real, messy data.

```{r load-RS, echo = T, include = T, size = "small"}
# load the data, it is called DF
load("manu_data/RS14.Rdata")

# build the one-factor model 
model.rs <- "RS =~ RS1+RS2+RS3+RS4+RS5+RS6+RS7+RS8+RS9+RS10+RS11+RS12+RS13+RS14"
# run the multi-group CFA
results.rs <- mgcfa(
  model = model.rs,
  data = DF, 
  group = "sample", 
  group.equal = c("loadings", "intercepts", "residuals")
  )
```

```{r show-rs-results, eval = F, echo = T, include = T, size = "small"}
# how to get results in table 
results.rs$model_fit %>% 
        dplyr::select(model, AIC, BIC, cfi, tli, rmsea, srmr)
```

```{r rs-table, results = 'asis'}
apa_table(results.rs$model_fit %>% 
        dplyr::select(model, AIC, BIC, cfi, tli, rmsea, srmr), 
        digits = 3, 
        col.names = c("Model", "AIC", "BIC", "CFI", "TLI", "RMSEA", "SRMR"),
          caption = "Model Fit for RS-14 Example")
```

Table \@ref(tab:rs-table) indicates the results after running the one-factor model. There are several guidelines for assessing assessing a degradation in model fit [@cheung2002; @jin2020; @putnick2016; @counsell2020; @cao2022] but for the purposes of this illustration $\Delta$CFI \> .01 will be used. Table \@ref(tab:rs-table) indicates that fit was degraded when the constraint on equal item intercepts was added. The code below provides an example of testing each item individually by relaxing the constraints and recalculating the CFI. If these Items bring the CFI value back up to $\Delta$CFI \<= .01 from the metric model, then the model would be considering partially invariant at the scalar level. It seems unlikely that the residuals will show invariance, if partial scalar invariance can be found, as the drop in fit is quite large.

```{r partial-RS, echo = T, include = T, size = "small"}
partial.rs <-
  partial_mi(
    saved_model = results.rs$invariance_models$model.intercepts,
    data = DF,
    model = model.rs,
    group = "sample",
    # be sure to do only up to the step you are interested in
    group.equal = c("loadings", "intercepts"),
    partial_step = "intercepts")

partial.rs$fit_table %>% 
  dplyr::select(free.parameter, cfi)
```

The output indicates that RS6 and RS7 are potential items that could be relaxed to improve model fit and create a partial scalar invariant model (i.e., by picking the largest CFI values). The code below show to check the addition of these items, which are added one at a time. You use the `group.partial` open to "relax" or freely estimate that parameter for each group separately. 

```{r partial-RS7, echo = T, include = T, size = "small"}
# run the partially invariant model with group.partial
partial.rs.1 <- mgcfa(model = model.rs, 
                  data = DF, 
                  group = "sample", 
                  group.equal = c("loadings", "intercepts"),
                  group.partial = c("RS7~1"),
                  meanstructure = TRUE)

# examine the loadings 
partial.rs.1$model_coef %>% 
  filter(term == "RS7 ~1 ") %>% 
  filter(model == "intercepts") %>% 
  dplyr::select(term, group, estimate, std.error)

# examine the fit indices 
partial.rs.1$model_fit %>% 
  filter(model == "intercepts") %>% 
  dplyr::select(AIC, BIC, cfi, tli, rmsea, srmr)

# effect size model 
lavaan_dmacs(partial.rs.1$invariance_models$model.intercepts, "Clinical")$DMACS[7]
```

By examining our estimates, we can see that item seven on the RS-14 is estimated at nearly 5 points for the clinical sample, while the student sample has a lower mean around 4.5 points. Generally, students show higher means on the items of the RS14, but when all loadings and other intercepts are constrained to be equal, and this one item is relaxed, this pattern flips so that clinical groups show higher item intercepts. Given the scale is a 1-7 Likert type scale, .5 a point represents a potentially sizable change on the scale. Item seven covers perseverance after hardship, and all items can be found in the user manual for the scale at www.resiliencecenter.com. The effect size from $d_{MACS}$ suggests a small to medium effect, `r apa_num(lavaan_dmacs(partial.rs.1$invariance_models$model.intercepts, "Clinical")$DMACS[7])`. In this next code section, we repeat this process for the RS6, as the CFI for our model with only RS7 does not achieve the levels of partial invariance for our $\Delta$CFI criterion (i.e., \<= .01 downward change in fit: metric CFI = `r apa_p(results.rs$model_fit$cfi[5])`, partial scalar CFI = `r apa_p(partial.rs.1$model_fit$cfi[6])`). See Figure \@ref(fig:rs7-img) for the difference between item intercepts and latent means. 

```{r partial-RS6, echo = T, include = T, size = "small"}
# add the second intercept
partial.rs.2 <- mgcfa(model = model.rs, 
                  data = DF, 
                  group = "sample", 
                  group.equal = c("loadings", "intercepts"),
                  group.partial = c("RS7~1", "RS6~1"),
                  meanstructure = TRUE)

# examine the loadings 
partial.rs.2$model_coef %>% 
  filter(term == "RS6 ~1 ") %>% 
  filter(model == "intercepts") %>% 
  dplyr::select(term, group, estimate, std.error)
# examine the fit indices 
partial.rs.2$model_fit %>% 
  filter(model == "intercepts") %>% 
  dplyr::select(AIC, BIC, cfi, tli, rmsea, srmr)

# effect size model 
lavaan_dmacs(partial.rs.2$invariance_models$model.intercepts, "Clinical")$DMACS[6]
```

Again, we see about a half-point difference between our clinical and student samples for item 6, which is about drive to achieve. The CFI for this model does meet the requirements for partial invariance, `r apa_p(partial.rs.2$model_fit$cfi[6])`. The effect size is approximately the same at $d_{MACS}$ = `r apa_num(lavaan_dmacs(partial.rs.2$invariance_models$model.intercepts, "Clinical")$DMACS[6])`. See Figure \@ref(fig:rs6-img) shows the difference between item intercepts and latent means. 

```{r plot-RS7, include = T, echo = T, results = "small", eval = F}
# plot the image for RS7
plot_mi(
  data_coef = partial.rs.2$model_coef, 
  model_step = "intercepts", 
  item_name = "RS7", 
  x_limits = c(-1,1),
  y_limits = c(min(DF$RS7), max(DF$RS7)),
  conf.level = .95, 
  model_results = partial.rs.2$invariance_models$model.intercepts,
  # which latent variable do you want 
  lv_name = "RS" 
)$complete
```

```{r rs7-img, echo = F, include = T, size = "small", fig.cap="RS7 Item Invariance Visualization"}
# plot the image for RS7
plot_mi(
  data_coef = partial.rs.2$model_coef, 
  model_step = "intercepts", 
  item_name = "RS7", 
  x_limits = c(-1,1),
  y_limits = c(min(DF$RS7), max(DF$RS7)),
  conf.level = .95, 
  model_results = partial.rs.2$invariance_models$model.intercepts,
  # which latent variable do you want 
  lv_name = "RS" 
)$complete
```

```{r plot-RS6, include = T, echo = T, results = "small", eval = F}
# plot the image for RS6
plot_mi(
  data_coef = partial.rs.2$model_coef, 
  model_step = "intercepts", 
  item_name = "RS6", 
  x_limits = c(-1,1),
  y_limits = c(min(DF$RS6), max(DF$RS6)),
  conf.level = .95, 
  model_results = partial.rs.2$invariance_models$model.intercepts,
  # which latent variable do you want 
  lv_name = "RS" 
)$complete
```

```{r rs6-img, echo = F, include = T, size = "small", fig.cap="RS6 Item Invariance Visualization"}
plot_mi(
  data_coef = partial.rs.2$model_coef, 
  model_step = "intercepts", 
  item_name = "RS6", 
  x_limits = c(-1,1),
  y_limits = c(min(DF$RS6), max(DF$RS6)),
  conf.level = .95, 
  model_results = partial.rs.2$invariance_models$model.intercepts,
  # which latent variable do you want 
  lv_name = "RS" 
)$complete
```

Next, we would examine our replication potential for this model. Given our current results, we may not expect our intercepts to replicate. Given the order of `group.equal`, the boot function will select the first non-invariant step in the calculation of the effect size for potential replication. In our output, we do not see a loadings effect size, and this result occurs when *none* of the bootstrapped or random results are non-invariant. Therefore, we would expect the loadings to replicate (and the effect size would be 0 difference between bootstrapped and random, both showing invariance). The intercepts show a large (i.e., close to the max possible value) non-invariant effect, and therefore, we should not expect this model to show invariance in a replication. 

```{r model-boot-RS, include = T, echo = T, results = "small", eval = F}
boot.model.rs <- 
  bootstrap_rr(
    saved_configural = results.rs$model_configural,
    data = DF,
    model = model.rs, 
    group = "sample", 
    nboot = 1000, 
    invariance_index = "cfi",
    invariance_rule = .01, 
    group.equal = c("loadings", "intercepts", "residuals")
)
```

```{r model-boot-RS-out, include = T, echo = T, results = "small"}
boot.model.rs
```

Next, we would examine the strength of the effects of replication on each parameter at the intercept level. By examining Table  \@ref(tab:table-boot-effects), it is clear that most of the item means are unlikely to replicate, even though two particular items can be used to create partial invariance. Figures \@ref(fig:rs-partial-pic) and \@ref(fig:rs-partial-pic2) display the three plots provided in the `bootstrap_partial()` function. In general, we should expect $M_{D}$ = `r apa_num(boot.partial.rs$boot_summary %>% filter(invariant) %>% pull(mean_boot_difference) %>% mean())` when items are invariant and $M_{D}$ = `r apa_num(boot.partial.rs$boot_summary %>% filter(!invariant) %>% pull(mean_boot_difference) %>% mean())` when items are not invariant. The effect size of non-invariant items ranges from `r apa_num(boot.partial.rs$boot_summary %>% filter(!invariant) %>% pull(d_boot) %>% min(., na.rm = T))` to `r apa_num(boot.partial.rs$boot_summary %>% filter(!invariant) %>% pull(d_boot) %>% max(., na.rm = T))`. 

The density plot shown at the bottom of Figure \@ref(fig:rs-partial-pic) illustrates the likely reasons for the differences found in the top plots. It appears that many items show a bimodal distribution within group 1 (Clinical Sample) and when items are invariant, the intercept averages to the same intercept as group 2 (Student Sample). In non-invariant estimates, the same bimodal distributions are found, but they are more extreme than the student samples, and therefore, item show different averages due to the presence of two separate means of data. Further, some items also appear to show two separate student item averages within the data. This result suggests that it would be fruitful to understand a potential predictor of these differences or other confounding variable that separates these samples, creating differences in item averages. 

In summary, if one were planning a replication, the prediction would be that item intercepts would likely not replicate, with a large effect size (i.e., it is easy to judge $h_{nmi_p}$ close to the max of one as large). While this study found partial invariance by relaxing constraints on two individual items, bootstrapped partial invariance indicates that any item could potentially be problematic with an effect size averaging $d$ ~ 0.50 difference in means. While $d_{MACS}$ values represented a "small" effect based on previous publications, this effect may be muted by examining both loadings and intercepts. The results here suggest that the effect is driven by intercepts. The overall average score on items is high: $M_M$ = `r apa_num(mean(apply(DF[ , -ncol(DF)], 2, mean)))` ($M_{SD}$ = `r apa_num(mean(apply(DF[ , -ncol(DF)], 2, sd)))`). Given the mean standard deviation, a $d$ ~ 0.50 represents `r apa_num(mean(apply(DF[ , -ncol(DF)], 2, sd))/2)` or nearly one whole point on the scale. A researcher could decide that at least $d$ = 0.33 or at least a third of a standard deviation would be an important change and set that as their smallest effect size of interest for invariance. Further, a newly planned study should investigate what variables may predict when and why samples separate into bimodal representations for item means. 

```{r partial-boot-RS, include = T, echo = T, results = "small", eval = F}
boot.partial.rs <- 
  bootstrap_partial(
    saved_model = results.rs$invariance_models$model.intercepts,
    data = DF,
    model = model.rs, 
    group = "sample", 
    nboot = 1000, 
    invariance_index = "cfi",
    invariance_rule = .01, 
    invariance_compare = fitmeasures(results.rs$invariance_models$model.loadings, "cfi"), 
    partial_step = "intercepts",
    group.equal = c("loadings", "intercepts")
)
```

```{r table-boot-effects, results='asis'}
apa_table(boot.partial.rs$boot_effects,
          digits = 3, 
          caption = "Boot Partial Effects Results for RS-14 Intercepts")
```

```{r rs-partial-pic, include = T, fig.cap="RS14 scale invariance for item intercepts. The left panel indicates the raw score difference between groups and items, while the right panel indicates the effect size for group differences based on invariance."}

plot_grid(
  boot.partial.rs$invariance_plot,
  boot.partial.rs$effect_invariance_plot)
```

```{r rs-partial-pic2, include = T, fig.cap = "RS14 scale invariance density plots, illustrating invariant versus non-invariant bootstrapped and random runs for each parameter."}
suppressMessages((boot.partial.rs$density_plot))
```

# Discussion

In this tutorial, we examined how to use multiple tools to examine measurement invariance and its potential replication. Model fit comparisons and statistics can be paired with the proposed effect size measures, and a visualization to examine individual items and the overall latent mean scores. The impact of potential replication was estimated on the overall model and the individual parameters. Using real data, the effect of two non-invariant item intercepts was examined and visualized. This tutorial manuscript has provided a concrete way to plan for pre-registration and/or registered reports. Researchers could simulate results based on published or previously collected data to determine the likelihood and size of potential replication. They could plan and pre-register a smallest effect of interest. For example, we may determine that an $h_{nmi_p}$ value above .20 represents an important level of non-invariance for our model overall, while $h_{nmi_p}$ > .30 for any individual parameter warrant caution against invariance for groups. Others have begun to discuss the importance of focusing on effects in the scale of the data and their practical importance [@cumming2012; @anvari2021]. 

From the example, our interpretation may be that the difference between group's latent means is large, as a `r apa_num(partial.rs.2$model_coef %>% filter(term == "RS ~1 ") %>% slice_tail() %>% pull(estimate))` change on a 7 point scale is approximately 10% more resiliency for students when compared to the clinical sample. Practically, 10% in resiliency for an area of the United States (Mississippi) often hit with natural disasters (hurricanes, tornadoes, floods) and high levels of poverty would be very important. Even the smaller difference of .5 point on each individual item could translate into increases in resiliency, and these results may elucidate avenues for further exploration into areas of focus within resiliency, given the items.

What do the results of a study on measurement invariance with these results tell us about replication, generalizability, and validity overall? If a researcher decides their effects are large, they should likely caution against suggesting that these scores are directly comparable without weighting or other adjustment. Let's consider a scenario wherein the change metric between models picked (i.e., $\Delta$CFI, $\Delta$RMSEA) indicates a "significant" change in model fit. However, if both the effect size and a visual inspection of the invariance indicates a small difference, we may decide to lessen the practical importance of those results, much like "just significant" *p*-values with small effect sizes are treated now. Given that the goal of measurement invariance is to compare *estimates*, we should expect some differences across samples due to the nature of sampling and estimation. It may be that many of the published models presented represent these effects - small variations between groups due to sampling error or other small crud - but do not represent a fundamental problem with the measurement or generalizability of the results.

\newpage

# References

::: {#refs custom-style="Bibliography"}
:::



\newpage

# (APPENDIX) Appendix {-}

```{r child = "appendix_1.Rmd"}
```

```{r child = "appendix_2.Rmd"}
```

```{r child = "appendix_3.Rmd"}
```

```{r child = "appendix_4.Rmd"}
```

```{r child = "appendix_5.Rmd"}
```

```{r child = "appendix_6.Rmd"}
```

