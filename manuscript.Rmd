---
title             : "Visualizing and Interpreting Multi-Group Confirmatory Factor Analysis"
shorttitle        : "VISUAL MGCFA"

author: 
  - name          : "Erin M. Buchanan"
    affiliation   : "1"
    corresponding : yes    # Define only one corresponding author
    address       : "326 Market St., Harrisburg, PA, USA"
    email         : "ebuchanan@harrisburgu.edu"
    role: # Contributorship roles (e.g., CRediT, https://credit.niso.org/)
      - "Conceptualization"
      - "Writing - Original Draft Preparation"
      - "Writing - Review & Editing"

affiliation:
  - id            : "1"
    institution   : "Harrisburg University of Science and Technology"

authornote: |
  Add complete departmental affiliations for each author here. Each new line herein must be indented, like this line.

  Enter author note here.

abstract: |
  Latent variable modeling as a lens for psychometric theory is a popular tool for social scientists to examine measurement of constructs [@beaujean2014]. Journals such as *Assessment* regularly publish articles supporting new or previously established measures of latent constructs (e.g., depression, anxiety) wherein a measurement model is established for the scale in question. These measurement models designate the relationship between the measured, observed variables, and the underlying construct, with the assumption that these relations hold in many samples. Confirmatory factor analysis can be used to investigate the replicability and generalizability of the measurement model in new samples, while multi-group confirmatory factor analysis is used to examine the measurement model across groups within samples [@brown2015]. With the rise of the replication crisis and "psychology's renaissance" [@nelson2018], interest in divergence in measurement has increased, often focused on small parameter differences within the latent model. While the statistical procedure for examining measurement invariance is moderately well established, it is clear that the toolkit for inspecting these results is lacking. This manuscript will outline ways to visualize potential non-invariance, to supplement large numbers of tables that often overwhelm a reader within these published reports. Further, given these visualizations, readers will learn how to interpret the impact and size of the proposed non-invariance in models. While it is tempting to suggest that problems with replication and generalizability are simply issues with measurement, it is crucial to remember that all models have variability and error, even those models estimating the differences between item functioning, such as multi-group confirmatory factor analysis. This manuscript will help provide a framework for researchers interested in registered reports in this area.
  
keywords          : "multigroup confirmatory factor analysis, measurement invariance, visualization, effect size"

floatsintext      : no
linenumbers       : yes
draft             : no
mask              : no

figurelist        : no
tablelist         : no
footnotelist      : no

classoption       : "man"
output            : papaja::apa6_pdf
bibliography: references.bib
---

```{r libraries, include = FALSE}
library(papaja)
library(lavaan)
library(broom)
library(dplyr)
library(ggplot2)
# devtools::install_github("psyteachr/introdataviz")
# devtools::install_github("ddueber/dmacs")
library(introdataviz)
library(dmacs)
library(cowplot)
```

```{r cfa-function, include = FALSE}
# CFA function
mgcfa <- function(data, group, model){
  
  group_names <- unique(data[ , group])
  
  model.overall <- cfa(model = model, data = data)
  model.group1 <- cfa(model = model, data = subset(data, group == group_names[1]))
  model.group2 <- cfa(model = model, data = subset(data, group == group_names[2]))
  model.configural <- cfa(model = model, data = data, group = group, meanstructure = T)
  model.metric <- cfa(model = model, data = data, group = group, group.equal = "loadings")
  model.scalar <- cfa(model = model, data = data, group = group, group.equal = c("loadings", "intercepts"))
  model.strict <- cfa(model = model, data = data, group = group, group.equal =  c("loadings", "intercepts", "residuals"))
  
  model_coef <- bind_rows(
    tidy(model.overall, conf.level = .95) %>% mutate(model = "overall"), 
    tidy(model.group1, conf.level = .95) %>% mutate(model = "group1"), 
    tidy(model.group2, conf.level = .95) %>% mutate(model = "group2"), 
    tidy(model.configural, conf.level = .95) %>% mutate(model = "configural"), 
    tidy(model.metric, conf.level = .95) %>% mutate(model = "metric"), 
    tidy(model.scalar, conf.level = .95) %>% mutate(model = "scalar"), 
    tidy(model.strict, conf.level = .95) %>% mutate(model = "strict")
  )
    
  model_fit <- bind_rows(
    glance(model.overall) %>% mutate(model = "overall"), 
    glance(model.group1) %>% mutate(model = "group1"), 
    glance(model.group2) %>% mutate(model = "group2"), 
    glance(model.configural) %>% mutate(model = "configural"), 
    glance(model.metric) %>% mutate(model = "metric"), 
    glance(model.scalar) %>% mutate(model = "scalar"), 
    glance(model.strict) %>% mutate(model = "strict")
    )
  
  return(list(
    "model_coef" = model_coef,
    "model_fit" = model_fit,
    "model.overall" = model.overall,
    "model.group1" = model.group1,
    "model.group2" = model.group2,
    "model.configural" = model.configural,
    "model.metric" = model.metric,
    "model.scalar" = model.scalar,
    "model.strict" = model.strict
  ))
  
}
```

```{r test-function, eval = F, include = F}
# temp test
data_coef = results.large.res$model_coef
model_step = "configural" 
item_name = "q4"
x_limits = c(-1,1)
y_limits = c(min(df.large.res$q4), max(df.large.res$q4))
ci_level = .95
model_results = results.invariant$model.configural
lv_name = "lv"
```

```{r plot-function, include = FALSE}
plot_mgcfa <- function(data_coef, # output from model_coef
                       model_step, # which model
                       item_name, # name of observed item
                       x_limits = c(-1,1), # LV limits to graph
                       y_limits, # Y min and max in data 
                       ci_level, # what ci do you want
                       model_results, # what model results do you want 
                       lv_name # which latent is the observed variable on
                       ){
  
  # calculate cutoff
  cutoff <- qt(p = (1-ci_level)/2, 
               df = sum(unlist(model_results@Data@nobs)), 
               lower.tail = F)
  
  # first get the data
  graph.data <- data_coef %>% # put in tidy coefficients
  filter(model == model_step) %>% # pick a model
  filter(grepl(item_name, term)) %>%  # pick a question
  mutate(group = factor(group, levels = names(table(data_coef$group)), labels = c("Group 1", "Group 2"))) 
  
  # make ribbon data y = slope*x + intercept for ci for slopes 
  ribbondata <- bind_rows(
    data.frame(
    x = seq(from = x_limits[1] - 1,  
            to = x_limits[2] + 1, 
            by = .05), 
    group = unique(graph.data$group)[1]
  ) %>% 
    mutate(ymin = (graph.data %>% filter(op == "=~") %>% 
                 slice_head() %>% pull(estimate) * x) - 
             (cutoff*graph.data %>% filter(op == "=~") %>% 
                    slice_head() %>% pull(std.error)) +
             graph.data %>% filter(op == "~1") %>% 
                 slice_head() %>% pull(estimate), 
           ymax = (graph.data %>% filter(op == "=~") %>% 
                 slice_head() %>% pull(estimate) * x) + 
             (cutoff*graph.data %>% filter(op == "=~") %>% 
                    slice_head() %>% pull(std.error)) +
             graph.data %>% filter(op == "~1") %>% 
                 slice_head() %>% pull(estimate)), 
    data.frame(
      x = seq(from = x_limits[1] - 1,  
              to = x_limits[2] + 1, 
              by = .05), 
      group = unique(graph.data$group)[2]
    ) %>% 
      mutate(ymin = (graph.data %>% filter(op == "=~") %>% 
                   slice_tail() %>% pull(estimate) * x) - 
               (cutoff*graph.data %>% filter(op == "=~") %>% 
                      slice_tail() %>% pull(std.error)) +
               graph.data %>% filter(op == "~1") %>% 
                   slice_tail() %>% pull(estimate), 
             ymax = (graph.data %>% filter(op == "=~") %>% 
                   slice_tail() %>% pull(estimate) * x) + 
               (cutoff*graph.data %>% filter(op == "=~") %>% 
                      slice_tail() %>% pull(std.error)) +
               graph.data %>% filter(op == "~1") %>% 
                   slice_tail() %>% pull(estimate))
  )
  
  # make point data to draw on the intercepts 
  pointdata <- data.frame(
  x = c(0,0),
  y = graph.data %>% filter(op == "~1") %>% pull(estimate), 
  group = graph.data %>% filter(op == "~1") %>% pull(group),
  ymin = graph.data %>% filter(op == "~1") %>% pull(estimate) - 
    cutoff * graph.data %>% filter(op == "~1") %>% pull(std.error), 
  ymax = graph.data %>% filter(op == "~1") %>% pull(estimate) + 
    cutoff * graph.data %>% filter(op == "~1") %>% pull(std.error)
  )
  
  # make the line data to draw on the slopes
  linedata <- data.frame(
  slope = graph.data %>% filter(op == "=~") %>% pull(estimate), 
  intercept = graph.data %>% filter(op == "~1") %>% pull(estimate), 
  group = graph.data %>% filter(op == "~1") %>% pull(group)
  )
  
  # make the distributions for the residuals 
  violindata <- data.frame(
  y = c(rnorm(n = 1000, 
            mean = graph.data %>% filter(op == "~~") %>% 
              slice_head() %>% pull(estimate), 
            sd = graph.data %>% filter(op == "~~") %>% 
              slice_head() %>% pull(std.error)), 
        rnorm(n = 1000, 
            mean = graph.data %>% filter(op == "~~") %>% 
              slice_tail() %>% pull(estimate), 
            sd = graph.data %>% filter(op == "~~") %>% 
              slice_tail() %>% pull(std.error))),
  group = c(rep(graph.data %>% filter(op == "~~") %>% 
              slice_head() %>% pull(group), 1000),
            rep(graph.data %>% filter(op == "~~") %>% 
              slice_tail() %>% pull(group), 1000)), 
  x = 1
  )
  
  # make the latent mean data for right panel
  latent_predict <- predict(model_results)
  latent_means <- data.frame(
    c(latent_predict[[1]], latent_predict[[2]])
    )
  colnames(latent_means) <- colnames(latent_predict[[1]])
  latent_means$group <- rep(names(latent_predict), 
                  times = c(length(latent_predict[[1]]), 
                           length(latent_predict[[2]])))
  
  latent_means$lv <- latent_means[ , lv_name]
  
  # make a plot of the variance
  variance_plot <- 
  ggplot(violindata, aes(x = 1, y = y, color = group, fill = group)) + 
  geom_split_violin() + 
  theme_void() + 
  theme(legend.position = "none") + 
  stat_summary(fun = "mean",
               geom = "crossbar", 
               width = 0.5,
               colour = "black")
  
  # make the plot with intercepts and slopes
  intercept_plot <- 
  ggplot() + 
  # basic set up
  theme_classic() + 
  xlab("Latent Variable") + 
  ylab("Observed Variable") + 
  coord_cartesian(xlim = x_limits, ylim = y_limits) + 
  # plot the intercepts 
  geom_point(data = pointdata, 
             aes(x = x, y = y, color = group), 
             inherit.aes = FALSE) + 
  geom_errorbar(data = pointdata,
                aes(x = x, ymin = ymin, ymax = ymax, color = group), 
                inherit.aes = FALSE, width = .10) + 
  # plot the slopes
  geom_abline(data = linedata,
              aes(slope = slope, intercept = intercept, color = group)) + 
  geom_ribbon(data = ribbondata, 
              aes(x = x, ymin = ymin, ymax = ymax, fill = group), 
              inherit.aes = FALSE, alpha = .2) + 
  scale_color_discrete(name = "Group") + 
  scale_fill_discrete(name = "Group") + 
  geom_vline(xintercept = 0) + 
  theme(axis.line.y = element_blank())
  
  # make the latent means plot
  mean_plot <- ggplot(latent_means, aes(x = lv, fill = group)) + 
    geom_density(alpha = .2) + 
    theme_classic() + 
    xlab("Latent Variable") + 
    ylab("Density") + 
    geom_vline(data = latent_means %>% group_by(group) %>% summarize(mean = mean(lv)), 
               aes(xintercept = mean, color = group)) + 
    theme(legend.position = "none") 
  
  y_range = abs(y_limits[2] - y_limits[1])
  
  # line up the two plots 
  prow <- plot_grid(
    intercept_plot + 
      theme(legend.position = "none") + 
      annotation_custom(ggplotGrob(variance_plot), 
                        xmin = .25, xmax = 1, 
                        ymin = y_limits[1], ymax = y_limits[2]-y_range/1.8),
    mean_plot + 
      theme(legend.position = "none"),
    align = 'vh',
    hjust = -1,
    nrow = 1
  )
  
  # get the lengend
  legend_b <- get_legend(
    intercept_plot + 
      guides(color = guide_legend(nrow = 1)) +
      theme(legend.position = "bottom")
  )
  
  # send out the plot 
  plot_grid(prow, legend_b, ncol = 1, rel_heights = c(1, .1))
  
}
```

```{r analysis-preferences}
# Seed for random number generation
set.seed(84393)
knitr::opts_chunk$set(cache.extra = knitr::rand_seed)
```

Outline

-   talk about LVM

-   talk about cfa

-   talk about mgcfa

-   how are measurement and replication/crisis related

-   why it is a bad idea to say that replication/crisis are *because* bad measurement

-   how can we visualize and interpret MGCFA to help us understand the impact of measurement differences

By the end of this tutorial manuscript, readers will:

1.  Be able to create visualizations for common steps to multi-group confirmatory factor analysis.
2.  Be able to interpret the impact and size of potential non-invariance on measurement.
3.  Understand the impact of measurement variability on replication and generalizability.

# Method

## Design and Analysis

Data was simulated using the `simulateData` function in the *R* package `lavaan` [@rosseel2012] assuming multivariate normality using a $\mu$ of 0 and $\sigma$ of 1 for the data. This function allows you to write `lavaan` syntax for your model with estimated values to generate data for observed variables. The data included two groups of individuals ("Group 1", "Group 2") for a multi-group confirmatory factor analysis (\$n\_{group}\$ = 250, *N* = 500). The latent variables were assumed to be continuous normal. The model consisted of five observed items predicted by one latent variable (`lv =~ q1 + q2 + q3 + q4 + q5`); however, the demonstration in this manuscript extends to multiple latent variables and other combinations of observed variables. Each item was assumed to be related to the latent variable with loadings approximately equal to .40 to .80, except when cases of non-invariance on the loadings was assumed.

The @brown2015 steps of testing measurement invariance are demonstrated in this manuscript for illustration purposes, but in line with @stark2006 suggestions, the visualizations show the impact of loadings and intercepts together. The configural model was analyzed nesting both groups into the same CFA model requiring that both groups show the same model structure, but all other parameters are free to vary between groups. The metric model constrained the factor loadings of each group to be equal within the model. The scalar model then constrained the item intercepts (i.e., item mean) to be equal across groups. Finally, the strict model constrained the item variances (i.e., error variances) to be equal for each item across groups. These models are normally tested sequentially, and a convenience function `mgcfa` is provided in the supplemental documents for this manuscript.

The data was then simulated to represent invariance across all model steps, small, medium, and large invariance using $d_{MACS}$ estimated sizes from @nye2019. While $d_{MACS}$ is used primarily for an effect size of the (non)-invariance for intercepts and loadings together, a similar approach was taken for the estimation of small, medium, and large effects on the residuals. The effect size is presented for all models, calculated from the *dmacs* package [@dueber2023, @nye2011]. Only one item in each model was manipulated from the invariant model to create the non-invariant models.

```{r create-models}
# overall model
model.overall <- "lv =~ q1 + q2 + q3 + q4 + q5"

# build invariant model one factor
model.invariant.g1 <- "lv =~ .8*q1 + .4*q2 + .6*q3 + .3*q4 + .6*q5 
q4 ~~ 1*q4
q4 ~ 0*1"
model.invariant.g2 <- "lv =~ .77*q1 + .43*q2 + .58*q3 + .3*q4 + .61*q5
q4 ~~ 1*q4
q4 ~ 0*1"

# loadings
model.small.load.g2 <- "lv =~ .77*q1 + .43*q2 + .58*q3 + .5*q4 + .61*q5"
model.med.load.g2 <- "lv =~ .77*q1 + .43*q2 + .58*q3 + .6*q4 + .61*q5"
model.large.load.g2 <- "lv =~ .77*q1 + .43*q2 + .58*q3 + 1.1*q4 + .61*q5"

# build invariance on intercepts .25, .50, and .75
model.small.int.g2 <- "lv =~ .77*q1 + .43*q2 + .58*q3 + .34*q4 + .61*q5
q4 ~ .25*1"
model.med.int.g2 <- "lv =~ .77*q1 + .43*q2 + .58*q3 + .34*q4 + .61*q5
q4 ~ .5*1"
model.large.int.g2 <- "lv =~ .77*q1 + .43*q2 + .58*q3 + .34*q4 + .61*q5
q4 ~ .75*1"

# build invariance on residuals .25, .50, and .75
model.small.res.g2 <- "lv =~ .77*q1 + .43*q2 + .58*q3 + .34*q4 + .61*q5
q4 ~~ .75*q4"
model.med.res.g2 <- "lv =~ .77*q1 + .43*q2 + .58*q3 + .34*q4 + .61*q5
q4 ~~ .5*q4"
model.large.res.g2 <- "lv =~ .77*q1 + .43*q2 + .58*q3 + .34*q4 + .61*q5
q4 ~~ .25*q4"
```

```{r create-data}
# simulate data invariant
df.invariant <- bind_rows(
  simulateData(model.invariant.g1, sample.nobs = 250, 
               meanstructure = T, model.type = "cfa",
               seed = 1234) %>% 
    mutate(group = "Group 1"), 
  simulateData(model.invariant.g2, sample.nobs = 250, 
               meanstructure = T, model.type = "cfa",
               seed = 1234) %>% 
    mutate(group = "Group 2") 
)

# simulate data small load
df.small.load <- bind_rows(
  simulateData(model.invariant.g1, sample.nobs = 250, 
               meanstructure = T, model.type = "cfa",
               seed = 1234) %>% 
    mutate(group = "Group 1"), 
  simulateData(model.small.load.g2, sample.nobs = 250, 
               meanstructure = T, model.type = "cfa",
               seed = 1234) %>% 
    mutate(group = "Group 2") 
)

# simulate data med load
df.med.load <- bind_rows(
  simulateData(model.invariant.g1, sample.nobs = 250, 
               meanstructure = T, model.type = "cfa",
               seed = 1234) %>% 
    mutate(group = "Group 1"), 
  simulateData(model.med.load.g2, sample.nobs = 250, 
               meanstructure = T, model.type = "cfa",
               seed = 1234) %>% 
    mutate(group = "Group 2") 
)

# simulate data large load
df.large.load <- bind_rows(
  simulateData(model.invariant.g1, sample.nobs = 250, 
               meanstructure = T, model.type = "cfa",
               seed = 1234) %>% 
    mutate(group = "Group 1"), 
  simulateData(model.large.load.g2, sample.nobs = 250, 
               meanstructure = T, model.type = "cfa",
               seed = 1234) %>% 
    mutate(group = "Group 2") 
)

# simulate data small int
df.small.int <- bind_rows(
  simulateData(model.invariant.g1, sample.nobs = 250, 
               meanstructure = T, model.type = "cfa",
               seed = 1234) %>% 
    mutate(group = "Group 1"), 
  simulateData(model.small.int.g2, sample.nobs = 250, 
               meanstructure = T, model.type = "cfa",
               seed = 1234) %>% 
    mutate(group = "Group 2") 
)

# simulate data med int
df.med.int <- bind_rows(
  simulateData(model.invariant.g1, sample.nobs = 250, 
               meanstructure = T, model.type = "cfa",
               seed = 1234) %>% 
    mutate(group = "Group 1"), 
  simulateData(model.med.int.g2, sample.nobs = 250, 
               meanstructure = T, model.type = "cfa",
               seed = 1234) %>% 
    mutate(group = "Group 2") 
)

# simulate data large int
df.large.int <- bind_rows(
  simulateData(model.invariant.g1, sample.nobs = 250, 
               meanstructure = T, model.type = "cfa",
               seed = 1234) %>% 
    mutate(group = "Group 1"), 
  simulateData(model.large.int.g2, sample.nobs = 250, 
               meanstructure = T, model.type = "cfa",
               seed = 1234) %>% 
    mutate(group = "Group 2") 
)

# simulate data small res
df.small.res <- bind_rows(
  simulateData(model.invariant.g1, sample.nobs = 250, 
               meanstructure = T, model.type = "cfa",
               seed = 1234) %>% 
    mutate(group = "Group 1"), 
  simulateData(model.small.res.g2, sample.nobs = 250, 
               meanstructure = T, model.type = "cfa",
               seed = 1234) %>% 
    mutate(group = "Group 2") 
)

# simulate data med res
df.med.res <- bind_rows(
  simulateData(model.invariant.g1, sample.nobs = 250, 
               meanstructure = T, model.type = "cfa",
               seed = 1234) %>% 
    mutate(group = "Group 1"), 
  simulateData(model.med.res.g2, sample.nobs = 250, 
               meanstructure = T, model.type = "cfa",
               seed = 1234) %>% 
    mutate(group = "Group 2") 
)

# simulate data large res
df.large.res <- bind_rows(
  simulateData(model.invariant.g1, sample.nobs = 250, 
               meanstructure = T, model.type = "cfa",
               seed = 1234) %>% 
    mutate(group = "Group 1"), 
  simulateData(model.large.res.g2, sample.nobs = 250, 
               meanstructure = T, model.type = "cfa",
               seed = 1234) %>% 
    mutate(group = "Group 2") 
)
```

```{r run-cfa}
# invariant CFA
results.invariant <- mgcfa(df.invariant, "group", model.overall)
d_invariant <- lavaan_dmacs(results.invariant$model.configural, RefGroup = "Group 1")

# loadings
results.small.load <- mgcfa(df.small.load, "group", model.overall)
results.med.load <- mgcfa(df.med.load, "group", model.overall)
results.large.load <- mgcfa(df.large.load, "group", model.overall)

d_small_load <- lavaan_dmacs(results.small.load$model.configural, RefGroup = "Group 1")
d_med_load <- lavaan_dmacs(results.med.load$model.configural, RefGroup = "Group 1")
d_large_load <- lavaan_dmacs(results.large.load$model.configural, RefGroup = "Group 1")

# intercepts
results.small.int <- mgcfa(df.small.int, "group", model.overall)
results.med.int <- mgcfa(df.med.int, "group", model.overall)
results.large.int <- mgcfa(df.large.int, "group", model.overall)

d_small_int <- lavaan_dmacs(results.small.int$model.configural, RefGroup = "Group 1")
d_med_int <- lavaan_dmacs(results.med.int$model.configural, RefGroup = "Group 1")
d_large_int <- lavaan_dmacs(results.large.int$model.configural, RefGroup = "Group 1")

# residuals
results.small.res <- mgcfa(df.small.res, "group", model.overall)
results.med.res <- mgcfa(df.med.res, "group", model.overall)
results.large.res <- mgcfa(df.large.res, "group", model.overall)

d_small_res <- lavaan_dmacs(results.small.res$model.configural, RefGroup = "Group 1")
d_med_res <- lavaan_dmacs(results.med.res$model.configural, RefGroup = "Group 1")
d_large_res <- lavaan_dmacs(results.large.res$model.configural, RefGroup = "Group 1")
```

```{r invariant-pic, include = T, fig.cap = "Invariant Model Visualization"}
plot_mgcfa(
  data_coef = results.invariant$model_coef, # output from model_coef
  model_step = "configural", # which model
  item_name = "q4", # name of observed item
  x_limits = c(-1,1), # LV limits to graph
  y_limits = c(min(df.invariant$q4), max(df.invariant$q4)), # Y min and max in data 
  ci_level = .95, # what ci do you want
  model_results = results.invariant$model.configural, # what model results do you want 
  lv_name = "lv"
)
```

```{r small-load-pic, include = T, fig.cap = "Small Loadings Model Visualization"}
plot_mgcfa(
  data_coef = results.small.load$model_coef, # output from model_coef
  model_step = "configural", # which model
  item_name = "q4", # name of observed item
  x_limits = c(-1,1), # LV limits to graph
  y_limits = c(min(df.small.load$q4), max(df.small.load$q4)), # Y min and max in data 
  ci_level = .95, # what ci do you want
  model_results = results.small.load$model.configural, # what model results do you want 
  lv_name = "lv"
)
```

```{r med-load-pic, include = T, fig.cap = "Medium Loadings Model Visualization"}
plot_mgcfa(
  data_coef = results.med.load$model_coef, # output from model_coef
  model_step = "configural", # which model
  item_name = "q4", # name of observed item
  x_limits = c(-1,1), # LV limits to graph
  y_limits = c(min(df.med.load$q4), max(df.med.load$q4)), # Y min and max in data 
  ci_level = .95, # what ci do you want
  model_results = results.med.load$model.configural, # what model results do you want 
  lv_name = "lv"
)
```

```{r large-load-pic, include = T, fig.cap = "Large Loadings Model Visualization"}
plot_mgcfa(
  data_coef = results.large.load$model_coef, # output from model_coef
  model_step = "configural", # which model
  item_name = "q4", # name of observed item
  x_limits = c(-1,1), # LV limits to graph
  y_limits = c(min(df.large.load$q4), max(df.large.load$q4)), # Y min and max in data 
  ci_level = .95, # what ci do you want
  model_results = results.large.load$model.configural, # what model results do you want 
  lv_name = "lv"
)
```


```{r small-int-pic, include = T, fig.cap = "Small Intercepts Model Visualization"}
plot_mgcfa(
  data_coef = results.small.int$model_coef, # output from model_coef
  model_step = "metric", # which model
  item_name = "q4", # name of observed item
  x_limits = c(-1,1), # LV limits to graph
  y_limits = c(min(df.small.int$q4), max(df.small.int$q4)), # Y min and max in data 
  ci_level = .95, # what ci do you want
  model_results = results.small.int$model.metric, # what model results do you want 
  lv_name = "lv"
)
```

```{r med-int-pic, include = T, fig.cap = "Medium Intercepts Model Visualization"}
plot_mgcfa(
  data_coef = results.med.int$model_coef, # output from model_coef
  model_step = "metric", # which model
  item_name = "q4", # name of observed item
  x_limits = c(-1,1), # LV limits to graph
  y_limits = c(min(df.med.int$q4), max(df.med.int$q4)), # Y min and max in data 
  ci_level = .95, # what ci do you want
  model_results = results.med.int$model.metric, # what model results do you want 
  lv_name = "lv"
)
```

```{r large-int-pic, include = T, fig.cap = "Large Intercepts Model Visualization"}
plot_mgcfa(
  data_coef = results.large.int$model_coef, # output from model_coef
  model_step = "metric", # which model
  item_name = "q4", # name of observed item
  x_limits = c(-1,1), # LV limits to graph
  y_limits = c(min(df.large.int$q4), max(df.large.int$q4)), # Y min and max in data 
  ci_level = .95, # what ci do you want
  model_results = results.large.int$model.metric, # what model results do you want 
  lv_name = "lv"
)
```

```{r small-res-pic, include = T, fig.cap = "Small Residuals Model Visualization"}
plot_mgcfa(
  data_coef = results.small.res$model_coef, # output from model_coef
  model_step = "scalar", # which model
  item_name = "q4", # name of observed item
  x_limits = c(-1,1), # LV limits to graph
  y_limits = c(min(df.small.res$q4), max(df.small.res$q4)), # Y min and max in data 
  ci_level = .95, # what ci do you want
  model_results = results.small.res$model.scalar, # what model results do you want 
  lv_name = "lv"
)
```

```{r med-res-pic, include = T, fig.cap = "Medium Residuals Model Visualization"}
plot_mgcfa(
  data_coef = results.med.res$model_coef, # output from model_coef
  model_step = "scalar", # which model
  item_name = "q4", # name of observed item
  x_limits = c(-1,1), # LV limits to graph
  y_limits = c(min(df.med.res$q4), max(df.med.res$q4)), # Y min and max in data 
  ci_level = .95, # what ci do you want
  model_results = results.med.res$model.scalar, # what model results do you want 
  lv_name = "lv"
)
```

```{r large-res-pic, include = T, fig.cap = "Large Residuals Model Visualization"}
plot_mgcfa(
  data_coef = results.large.res$model_coef, # output from model_coef
  model_step = "scalar", # which model
  item_name = "q4", # name of observed item
  x_limits = c(-1,1), # LV limits to graph
  y_limits = c(min(df.large.res$q4), max(df.large.res$q4)), # Y min and max in data 
  ci_level = .95, # what ci do you want
  model_results = results.large.res$model.scalar, # what model results do you want 
  lv_name = "lv"
)
```



# Results

# Discussion

Conclusions:

-   framework for submitted/interpreting reports

\newpage

# References

::: {#refs custom-style="Bibliography"}
:::

\newpage

# Appendix

```{r}
apa_table(results.invariant$model_fit %>% 
            select(model, AIC, BIC, cfi, tli, rmsea, srmr), 
          col.names = c("Model", "AIC", "BIC", "CFI", "TLI", "RMSEA", "SRMR"),
          caption = "Model Fit for Invariant Model")
```

```{r}
apa_table(results.small.load$model_fit %>% 
            select(model, AIC, BIC, cfi, tli, rmsea, srmr), 
          col.names = c("Model", "AIC", "BIC", "CFI", "TLI", "RMSEA", "SRMR"),
          caption = "Model Fit for Small Differences in Loadings")
```

```{r}
apa_table(results.med.load$model_fit %>% 
            select(model, AIC, BIC, cfi, tli, rmsea, srmr), 
          col.names = c("Model", "AIC", "BIC", "CFI", "TLI", "RMSEA", "SRMR"),
          caption = "Model Fit for Medium Differences in Loadings")
```

```{r}
apa_table(results.large.load$model_fit %>% 
            select(model, AIC, BIC, cfi, tli, rmsea, srmr), 
          col.names = c("Model", "AIC", "BIC", "CFI", "TLI", "RMSEA", "SRMR"),
          caption = "Model Fit for Large Differences in Loadings")
```

```{r}
apa_table(results.small.int$model_fit %>% 
            select(model, AIC, BIC, cfi, tli, rmsea, srmr), 
          col.names = c("Model", "AIC", "BIC", "CFI", "TLI", "RMSEA", "SRMR"),
          caption = "Model Fit for Small Differences in Intercepts")
```

```{r}
apa_table(results.med.int$model_fit %>% 
            select(model, AIC, BIC, cfi, tli, rmsea, srmr), 
          col.names = c("Model", "AIC", "BIC", "CFI", "TLI", "RMSEA", "SRMR"),
          caption = "Model Fit for Medium Differences in Intercepts")
```

```{r}
apa_table(results.large.int$model_fit %>% 
            select(model, AIC, BIC, cfi, tli, rmsea, srmr), 
          col.names = c("Model", "AIC", "BIC", "CFI", "TLI", "RMSEA", "SRMR"),
          caption = "Model Fit for Large Differences in Intercepts")
```

```{r}
apa_table(results.small.res$model_fit %>% 
            select(model, AIC, BIC, cfi, tli, rmsea, srmr), 
          col.names = c("Model", "AIC", "BIC", "CFI", "TLI", "RMSEA", "SRMR"),
          caption = "Model Fit for Small Differences in Residuals")
```

```{r}
apa_table(results.med.res$model_fit %>% 
            select(model, AIC, BIC, cfi, tli, rmsea, srmr), 
          col.names = c("Model", "AIC", "BIC", "CFI", "TLI", "RMSEA", "SRMR"),
          caption = "Model Fit for Medium Differences in Residuals")
```

```{r}
apa_table(results.large.res$model_fit %>% 
            select(model, AIC, BIC, cfi, tli, rmsea, srmr), 
          col.names = c("Model", "AIC", "BIC", "CFI", "TLI", "RMSEA", "SRMR"),
          caption = "Model Fit for Large Differences in Residuals")
```
