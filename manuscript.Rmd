---
title             : "Visualizing and Interpreting Multi-Group Confirmatory Factor Analysis"
shorttitle        : "VISUAL MGCFA"

author: 
  - name          : "Erin M. Buchanan"
    affiliation   : "1"
    corresponding : yes    # Define only one corresponding author
    address       : "326 Market St., Harrisburg, PA, USA"
    email         : "ebuchanan@harrisburgu.edu"
    role: # Contributorship roles (e.g., CRediT, https://credit.niso.org/)
      - "Conceptualization"
      - "Writing - Original Draft Preparation"
      - "Writing - Review & Editing"

affiliation:
  - id            : "1"
    institution   : "Harrisburg University of Science and Technology"

authornote: |
  Add complete departmental affiliations for each author here. Each new line herein must be indented, like this line.

  Enter author note here.

abstract: |
  Latent variable modeling as a lens for psychometric theory is a popular tool for social scientists to examine measurement of constructs [@beaujean2014]. Journals such as *Assessment* regularly publish articles supporting new or previously established measures of latent constructs (e.g., depression, anxiety) wherein a measurement model is established for the scale in question. These measurement models designate the relationship between the measured, observed variables, and the underlying construct, with the assumption that these relations hold in many samples. Confirmatory factor analysis can be used to investigate the replicability and generalizability of the measurement model in new samples, while multi-group confirmatory factor analysis is used to examine the measurement model across groups within samples [@brown2015]. With the rise of the replication crisis and "psychology's renaissance" [@nelson2018], interest in divergence in measurement has increased, often focused on small parameter differences within the latent model. While the statistical procedure for examining measurement invariance is moderately well established, it is clear that the toolkit for inspecting these results is lacking. This manuscript will outline ways to visualize potential non-invariance, to supplement large numbers of tables that often overwhelm a reader within these published reports. Further, given these visualizations, readers will learn how to interpret the impact and size of the proposed non-invariance in models. While it is tempting to suggest that problems with replication and generalizability are simply issues with measurement, it is crucial to remember that all models have variability and error, even those models estimating the differences between item functioning, such as multi-group confirmatory factor analysis. This manuscript will help provide a framework for researchers interested in registered reports in this area.
  
keywords          : "multigroup confirmatory factor analysis, measurement invariance, visualization, effect size"

floatsintext      : no
linenumbers       : yes
draft             : no
mask              : no

figurelist        : no
tablelist         : no
footnotelist      : no

classoption       : "man"
output            : papaja::apa6_pdf
bibliography: references.bib
---

```{r setup, include = FALSE}
library(papaja)
library(lavaan)
library(broom)
library(dplyr)
library(ggplot2)
# devtools::install_github("psyteachr/introdataviz")
library(introdataviz)

# CFA function
mgcfa <- function(data, group, model){
  
  group_names <- unique(data[ , group])
  
  model.overall <- cfa(model = model, data = data)
  model.group1 <- cfa(model = model, data = subset(data, group == group_names[1]))
  model.group2 <- cfa(model = model, data = subset(data, group == group_names[2]))
  model.configural <- cfa(model = model, data = data, group = group, meanstructure = T)
  model.metric <- cfa(model = model, data = data, group = group, group.equal = "loadings")
  model.scalar <- cfa(model = model, data = data, group = group, group.equal = c("loadings", "intercepts"))
  model.strict <- cfa(model = model, data = data, group = group, group.equal =  c("loadings", "intercepts", "residuals"))
  
  model_coef <- bind_rows(
    tidy(model.overall, conf.level = .95) %>% mutate(model = "overall"), 
    tidy(model.group1, conf.level = .95) %>% mutate(model = "group1"), 
    tidy(model.group2, conf.level = .95) %>% mutate(model = "group2"), 
    tidy(model.configural, conf.level = .95) %>% mutate(model = "configural"), 
    tidy(model.metric, conf.level = .95) %>% mutate(model = "metric"), 
    tidy(model.scalar, conf.level = .95) %>% mutate(model = "scalar"), 
    tidy(model.strict, conf.level = .95) %>% mutate(model = "strict")
  )
    
  model_fit <- bind_rows(
    glance(model.overall) %>% mutate(model = "overall"), 
    glance(model.group1) %>% mutate(model = "group1"), 
    glance(model.group2) %>% mutate(model = "group2"), 
    glance(model.configural) %>% mutate(model = "configural"), 
    glance(model.metric) %>% mutate(model = "metric"), 
    glance(model.scalar) %>% mutate(model = "scalar"), 
    glance(model.strict) %>% mutate(model = "strict")
    )
  
  return(list(
    "model_coef" = model_coef,
    "model_fit" = model_fit
  ))
  
}
```

```{r analysis-preferences}
# Seed for random number generation
set.seed(84393)
knitr::opts_chunk$set(cache.extra = knitr::rand_seed)
```

Outline

-   talk about LVM

-   talk about cfa

-   talk about mgcfa

-   how are measurement and replication/crisis related

-   why it is a bad idea to say that replication/crisis are *because* bad measurement

-   how can we visualize and interpret MGCFA to help us understand the impact of measurement differences

Research Questions:

By the end of this tutorial manuscript, readers will: 1. Be able to create visualizations for common steps to multi-group confirmatory factor analysis. 2. Be able to interpret the impact and size of potential non-invariance on measurement. 3. Understand the impact of measurement variability on replication and generalizability.

# Methods

## Design

Data will be simulated based on a multivariate normal distribution using R. The data will include two groups of individuals for multi-group confirmatory factor analysis (ns = 250; N = 500). The latent variables will be assumed to be continuous normal, and the measured items will be simulated using a traditional 1-7 Likert-type scale, matching many of the types of scales published in psychology and Assessment. Each item will be assumed to be related to the latent variable with loadings approximately equal to .60 to .80 (minus scenarios in which configural non-invariance is simulated).

## Variables

- Number of factors: one and two latent variable models will be simulated with five measured items for each latent variable. 
- Area of invariance: a model with non-invariance at each stage will be simulated including configural, metric, scalar, and strict non-invariance. One model with complete invariance will be used for comparison purposes. 
- Size of invariance: the size of the invariance will be simulated at three levels.

none, small, medium, large 
two models
metric (loadings), scalar (intercepts), strict (residuals)

4X2X3

since these are normally tested sequentially, we will only do one at a time 


https://stats.stackexchange.com/questions/593243/data-simulation-in-r-for-measurement-invariance

```{r create-data}
library(lavaan)

# build invariant model one factor
model.invariant.g1 <- "lv =~ .9*q1 + .4*q2 + .6*q3 + .3*q4 + .6*q5"
model.invariant.g2 <- "lv =~ .87*q1 + .43*q2 + .54*q3 + .4*q4 + .61*q5"
model.overall <- "lv =~ q1 + q2 + q3 + q4 + q5"

# simulate data
df.invariant <- bind_rows(
  simulateData(model.invariant.g1, sample.nobs = 250, 
               meanstructure = T, model.type = "cfa") %>% 
    mutate(group = "Group 1"), 
  simulateData(model.invariant.g2, sample.nobs = 250, 
               meanstructure = T, model.type = "cfa") %>% 
    mutate(group = "Group 2") 
)

```

```{r run-cfa}
# invariant CFA
results.invariant <- mgcfa(df.invariant, "group", model.overall)
```

```{r invariant-picture}
graph.data <- results.invariant$model_coef %>% # put in tidy coefficients
  filter(model == "configural") %>% # pick a model
  filter(grepl("q4", term)) %>%  # pick a question
  mutate(group = factor(group, levels = c(1,2), labels = c("Group 1", "Group 2"))) 

graph.data$low <- graph.data$estimate - 2*graph.data$estimate
graph.data$high <- graph.data$estimate + 2*graph.data$estimate

# X = latent variable (so interpretation is z-score)
# Y = observed variable
# set x and y limits
x_limits <- c(-1,1)
y_limits <- c(min(df.invariant$q4), max(df.invariant$q4))

# make ribbon data y = slope*x + intercept
ribbondata <- bind_rows(
  data.frame(
  x = seq(from = x_limits[1] - 1,  
          to = x_limits[2] + 1, 
          by = .05), 
  group = unique(graph.data$group)[1]
) %>% 
  mutate(ymin = (graph.data %>% filter(op == "=~") %>% 
               slice_head() %>% pull(estimate) * x) - 
           (2*graph.data %>% filter(op == "=~") %>% 
                  slice_head() %>% pull(std.error)) +
           graph.data %>% filter(op == "~1") %>% 
               slice_head() %>% pull(estimate), 
         ymax = (graph.data %>% filter(op == "=~") %>% 
               slice_head() %>% pull(estimate) * x) + 
           (2*graph.data %>% filter(op == "=~") %>% 
                  slice_head() %>% pull(std.error)) +
           graph.data %>% filter(op == "~1") %>% 
               slice_head() %>% pull(estimate)), 
  data.frame(
    x = seq(from = x_limits[1] - 1,  
            to = x_limits[2] + 1, 
            by = .05), 
    group = unique(graph.data$group)[2]
  ) %>% 
    mutate(ymin = (graph.data %>% filter(op == "=~") %>% 
                 slice_tail() %>% pull(estimate) * x) - 
             (2*graph.data %>% filter(op == "=~") %>% 
                    slice_tail() %>% pull(std.error)) +
             graph.data %>% filter(op == "~1") %>% 
                 slice_tail() %>% pull(estimate), 
           ymax = (graph.data %>% filter(op == "=~") %>% 
                 slice_tail() %>% pull(estimate) * x) + 
             (2*graph.data %>% filter(op == "=~") %>% 
                    slice_tail() %>% pull(std.error)) +
             graph.data %>% filter(op == "~1") %>% 
                 slice_tail() %>% pull(estimate))
)

pointdata <- data.frame(
  x = c(0,0),
  y = graph.data %>% filter(op == "~1") %>% pull(estimate), 
  group = graph.data %>% filter(op == "~1") %>% pull(group),
  ymin = graph.data %>% filter(op == "~1") %>% pull(estimate) - 
    2 * graph.data %>% filter(op == "~1") %>% pull(std.error), 
  ymax = graph.data %>% filter(op == "~1") %>% pull(estimate) + 
    2 * graph.data %>% filter(op == "~1") %>% pull(std.error)
)

linedata <- data.frame(
  slope = graph.data %>% filter(op == "=~") %>% pull(estimate), 
  intercept = graph.data %>% filter(op == "~1") %>% pull(estimate), 
  group = graph.data %>% filter(op == "~1") %>% pull(group)
)

violindata <- data.frame(
  y = c(rnorm(n = 1000, 
            mean = graph.data %>% filter(op == "~~") %>% 
              slice_head() %>% pull(estimate), 
            sd = graph.data %>% filter(op == "~~") %>% 
              slice_head() %>% pull(std.error)), 
        rnorm(n = 1000, 
            mean = graph.data %>% filter(op == "~~") %>% 
              slice_tail() %>% pull(estimate), 
            sd = graph.data %>% filter(op == "~~") %>% 
              slice_tail() %>% pull(std.error))),
  group = c(rep(graph.data %>% filter(op == "~~") %>% 
              slice_head() %>% pull(group), 100),
            rep(graph.data %>% filter(op == "~~") %>% 
              slice_tail() %>% pull(group), 100)), 
  x = 1
)

latent_means <- data.frame(
  predict(model.overall.model), 
  group = df.invariant$group
)

variance_plot <- 
  ggplot(violindata, aes(x = 1, y = y, color = group, fill = group)) + 
  geom_split_violin() + 
  theme_void() + 
  theme(legend.position = "none") + 
  stat_summary(fun = "mean",
               geom = "crossbar", 
               width = 0.5,
               colour = "black")

intercept_plot <- 
  ggplot() + 
  # basic set up
  theme_classic() + 
  xlab("Latent Variable") + 
  ylab("Observed Variable") + 
  coord_cartesian(xlim = x_limits, ylim = y_limits) + 
  # plot the intercepts 
  geom_point(data = pointdata, 
             aes(x = x, y = y, color = group), 
             inherit.aes = FALSE) + 
  geom_errorbar(data = pointdata,
                aes(x = x, ymin = ymin, ymax = ymax, color = group), 
                inherit.aes = FALSE, width = .10) + 
  # plot the slopes
  geom_abline(data = linedata,
              aes(slope = slope, intercept = intercept, color = group)) + 
  geom_ribbon(data = ribbondata, 
              aes(x = x, ymin = ymin, ymax = ymax, fill = group), 
              inherit.aes = FALSE, alpha = .2) + 
  scale_color_discrete(name = "Group") + 
  scale_fill_discrete(name = "Group") + 
  geom_vline(xintercept = 0)
  
# latent means
mean_plot <- ggplot(latent_means, aes(x = lv, fill = group)) + 
  geom_density(alpha = .2) + 
  theme_classic() + 
  xlab("Latent Variable") + 
  ylab("Density") + 
  geom_vline(data = latent_means %>% group_by(group) %>% summarize(mean = mean(lv)), 
             aes(xintercept = mean, color = group)) + 
  theme(legend.position = "none") 
```



```{r}


model.2 <- "lv =~ q1 + q2 + q3 + q4 + q5
lv2 =~ q6 + q7 + q8 + q9 + q10
"

# Packages
library(lavaan)

# specify population model for group 1 and group 2
population_model_g1 <-'f1=~x1+.6*x2+.7*x3+0.5*x4'
population_model_g2 <-'f1=~x1+.6*x2+.7*x3+0.4*x4'

# Sumulate data
set.seed(1234)
model_data_g1<-lavaan::simulateData(population_model_g1,sample.nobs=500)
model_data_g2<-lavaan::simulateData(population_model_g2,sample.nobs=500)

# Add group label
model_data_g1$group <- "Group1"
model_data_g2$group <- "Group2"

# put data into one data frame
model_data_all <- cbind(model_data_g1,model_data_g2)

```

#### delete this 
Across all studies, results indicated that the majority of the standardized factor loading differ-
ences were below .10, and few were greater than .50. Given these results, small, medium, and large
differences in factor loadings were operationalized as .10, .20, and .30, respectively. In other words,
the factor loadings in the focal group were increased by .10, .20, or .30 to simulate MNE in various
conditions. In contrast, intercept differences in the literature were larger than the factor loading
differences, and the majority of these differences were below .20, but very few were above 1.00.
Therefore, intercept differences across groups were operationalized as .25, .50, and .75. Figures A1
and A2 in the online supplemental material show the distributions of differences between the
standardized factor loadings and intercepts in the reference and focal groups.


## Data analysis

Multi-group confirmatory factor analysis will be examined across the simulated two groups of individuals using lavaan (Rosseel, 2012) focusing on the most common procedure outlined in Brown (2015). Each stage of measurement invariance (i.e., configural, metric, scalar, and strict) will be examined in the simulated data demonstrating how to visualize results using common tools, such as ggplot2 (Wickham et al., 2021). These visualizations will be compared across differences in non-invariance size to illustrate how to interpret the size of the non-invariance. Last, these effects will be examined on total score measurement (i.e., latent means) to explore the potential impacts on replication. Finally, suggestions will be provided for framing registered reports using multi-group confirmatory factor analysis.

# Results

# Discussion

Conclusions:

-   framework for submitted/interpreting reports

\newpage

# References

::: {#refs custom-style="Bibliography"}
:::


Visualizing Measurement Model Parameters for Tests of (Non)Invariance/DIF: 
Purpose, Presentation, and a New R Package

Type: Tutorial 

Authors: John K. Sakaluk, Brenton M. Wiernik, Flavio Azevedo, Alex J. Denison, and Erin M. Buchanan

Email: jsakaluk@uwo.ca 

300 Word Summary: 
Latent variable psychometric theory remains psychology’s most popular framework for conceptualizing and studying psychological entities across its many subdisciplines. Indeed, psychologists regularly use latent variable analysis frameworks to generate a “measurement model”: a statistical statement of the relations between a given set of observed variables and their construct(s) when attempting to describe and quantify the substance of the theoretical entities that they study. A core--and tacit--assumption, however of latent variables is that the measurement parameters are consistent between groups or across a given continuous covariate, as divergent measurement model parameters otherwise threaten the validity of the estimation, testing, and comparison of structural parameters. Psychologists therefore are often tasked with testing to establish “measurement invariance” (or equivalently, to rule out “differential item functioning”) for their latent variables of interest. But whereas the estimation, testing, and comparison of measurement model parameters is commonplace, the visualization of these parameters is virtually nonexistent, largely owing to a dearth of any standardized manner by which these parameters ought to be depicted. Without any compelling visualization techniques, the process of evaluating measurement (non)invariance seems likely to persist in facilitating relatively uninformative all-or-none omnibus testing, without any possibility of researchers identifying meaningful patterns. We therefore propose to describe, apply, and develop supporting analytic materials (e.g., R functions and tutorials) to visualize measurement modeling parameters. Our approach will be amenable to either multi-group comparisons or continuous covariate examinations of measurement modeling parameters and will enable emphasizing particular parameters and/or variables, while also providing visual information about the model as a whole. Finally, our approach will emphasize accessibility, in terms of: 1) creating easy-to-use functions for interested users to adopt in their own work, which will create 2) publication-ready greyscale figures and/or; 3) figures in a colorblind-friendly palette.  
Prior Req’d Knowledge:
R coding
Regression
Latent variable theory and measurement modeling 


What: 
Rationale
Easy-to-use functionality/package for visualizations of measurement modeling output for DIF/Noninvariance-Testing, including:
Scale of measuremen-friendly for source of noninvariance
Multi-Group
Continuous-Covariate
Multilevel(s) Targeting
Measurement parameter (loading, intercept, residuals(?))
Item level (e.g., noninvariance/DIF effect sizes?)
Test level
Application/didactic example
Existing data sets? And/or?
Simulated data sets?

Guiding Programming Values
Easy to use
Should use df and fitted lavaan object and little else
Easy to incorporate into pubs
Should have a template option for APA-compliant figures (i.e., greyscale)
Accessibility
Should have a template(s) option for beautiful and colourblind-friendly palette(s)
Modifiable
Should return ggplot2::ggplot objects that the user can modify as desired; perhaps a “basic” template option that returns the geoms_ with little else?


March 24 Meeting

Introductions


Rehash of project goals/features + Discussion
Visualization of measurement model parameters for noninvariance/DIF testing
Visualization types
Response curves (latent score X, predicted item score on Y)
IRT Sigmoidal curves
CFA item “curves” 
“Common” visualization style (simple intercepts/slopes) for MCCFA/RFA
Error variance could be a band 
Faceted by items
Test level observed score and latent score distributions
Densities with grouped observed + grouped latent scores
Variance decomposition signal:noise (communality to uniqueness) “candybar plots”
R Functions (take selection of items and group/covariate and/or MGCFA lavaan object)
Return ggplot object
Options for “canned” style (e.g., APA compliant) 
Didactic example
learnr tutorial(s) 


Preferred workflow/systems
lavaan:: focused
Github repo for package
Brenton with commit access on master branch
Others suggest changes with pull requests
Github issues for communication
Use Brown terminology
Configural
Metric
Scalar
Strict


Preferred roles
Toy examples for dev (two group multiple groups, continuous mimic, categorical mimic, sparse groups at different levels)
Erin’s examples 
Install the package examples if you want: devtools::install_github(“doomlab/learnSEM”) (I have a few more too, I’ll dig them up)
John: lavaan::HolzingerSwineford1939 and psych::bfi as preexisting/often used exemplar sets
Plot design in ggplot
Alex and Brenton and Flavio
Function writing
Alex and Brenton and John
Package dev/maintenance
Brenton
learnr tutorial(s)
Erin and John
Writing
John is happy to lead


Prefered timeline


Submission targets
AMPPS
BRM

